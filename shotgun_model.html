



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Shotgun Model &mdash; tk-framework-shotgunutils v5.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="tk-framework-shotgunutils v5.1.0 documentation" href="index.html"/>
        <link rel="next" title="Shotgun Hierarchy Model" href="shotgun_hierarchy_model.html"/>
        <link rel="prev" title="The Shotgun Utilities Framework" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
    <a href='http://developer.shotgunsoftware.com'>
    
        <img style='width: 191px;
                height: 60px; 
                margin: 2px;
                border-radius: 0px; 
                padding: 0px;' 
            src='_static/logo@2x.png'/>
    
    </a>
    

          
            <a href="index.html" class="icon icon-home"> tk-framework-shotgunutils
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Shotgun Model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-should-i-use-the-shotgun-model">Why should I use the Shotgun Model?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shotgun-model-hello-world">Shotgun Model Hello World</a></li>
<li class="toctree-l3"><a class="reference internal" href="#beyond-hello-world">Beyond Hello World</a></li>
<li class="toctree-l3"><a class="reference internal" href="#progress-spinner">Progress Spinner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-items">Data Items</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simpleshotgunmodel">SimpleShotgunModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shotgunentitymodel">ShotgunEntityModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shotgunmodel">ShotgunModel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="shotgun_hierarchy_model.html">Shotgun Hierarchy Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="shotgun_data.html">Shotgun Asynchronous Data Retriever</a></li>
<li class="toctree-l1"><a class="reference internal" href="task_manager.html">Background Task Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">Shotgun Toolkit Qt Settings Wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="shotgun_globals.html">Shotgun Globals Access</a></li>
</ul>

            
          
       
    <div style='margin-top: 50px;
                margin-left: 10px;
                margin-right: 10px;
                padding: 10px; 
                color: #b3b3b3; 
                font-size: 70%;
                border-radius: 3px;
                background-color: #444;
                line-height: 18px;
                '>    
    <style>
        a.custom_post_menu { display: inline; 
                             padding: 0px; 
                             text-decoration: underline; }
    </style>

    <b>tk-framework-shotgunutils</b> v5.1.0.<br>
    
        This documentation is part of the Shotgun Pipeline Toolkit.
    
    For more information, please visit
    <a class=custom_post_menu href='https://support.shotgunsoftware.com/home'>Shotgun Support</a>.
    The code associated with this documentation can be found 
    <a class=custom_post_menu href='https://github.com/shotgunsoftware/tk-framework-shotgunutils'>here</a>.

    </div>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">tk-framework-shotgunutils</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Shotgun Model</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="shotgun-model">
<h1>Shotgun Model<a class="headerlink" href="#shotgun-model" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The shotgun data model helps you build responsive, data rich applications quickly and leverage
Qt&#8217;s built-in model/view framework</p>
<img alt="_images/model_overview.png" src="_images/model_overview.png" />
<p>The Shotgun Model is a custom Qt Model specialized for Shotgun Queries. It uses a disk based cache
and runs queries asynchronously to Shotgun in the background for performance. In a nut shell, you
derive your own model class from it, set up a query, and then hook up your model to a Qt View which
will draw the data. The class contains several callbacks and allows for extensive customization, yet
tries to shadow and encapsulate a lot of the details.</p>
<img alt="_images/model_inheritance.png" src="_images/model_inheritance.png" />
<div class="section" id="why-should-i-use-the-shotgun-model">
<h3>Why should I use the Shotgun Model?<a class="headerlink" href="#why-should-i-use-the-shotgun-model" title="Permalink to this headline">¶</a></h3>
<p>Using the Shotgun Model means switching to Model/View based programming. While there is perhaps slightly more
overhead to get started with this, there are many benefits. The Shotgun Model (and the corresponding delegates
and Shotgun View components) is an attempt to bridge this gap and make it quick and painless to get started
with Qt Model/View programming.</p>
<p>Qt provides a strong and mature Model/View hierarchy which is robust and easy to work with. If you are not
familiar with it, please check the following links:</p>
<ul class="simple">
<li>Tutorial: <a class="reference external" href="http://qt-project.org/doc/qt-4.8/modelview.html">http://qt-project.org/doc/qt-4.8/modelview.html</a></li>
<li>Technical details: <a class="reference external" href="http://qt-project.org/doc/qt-4.8/model-view-programming.html">http://qt-project.org/doc/qt-4.8/model-view-programming.html</a></li>
</ul>
<p>The benefits with this approach will become evident as you scale your UIs and their complexity. Developing code
and tools where the data and the UI is combined will work in simple scenarios but for data rich applications
this approach becomes hard to maintain, difficult to reuse and typically scales poorly as the dataset complexity grows.
By leveraging Qts built-in functionality, you get access to a mature and well documented toolbox that makes
it quick to develop tools:</p>
<ul class="simple">
<li>A Shotgun model instance represents a single shotgun query. With two lines of code you can connect the resultset
of such a query with a standard Qt list, tree or table.</li>
<li>The Shotgun model is cached, meaning that all data is fetched in the background in a worker thread. This means that
the data in your UI will load up instantly and you never have to wait for shotgun. If the query result is different
than the cached result, the view will be updated on the fly as the data arrives.</li>
<li>With Qt you have access to SelectionModels, making it easy to create consistent selection behavior, even across
multiple views. With full keyboard support.</li>
<li>With Qt proxy models you can easily create interactive searching and filtering on the client side.</li>
<li>Views and models are optimized and will perform nicely even if you have thousands of items loaded.</li>
<li>Through the shotgun view module, you can easily control the Qt <em>delegates</em> system, making it easy to
draw custom UIs for each cell in your view.</li>
</ul>
</div>
<div class="section" id="shotgun-model-hello-world">
<h3>Shotgun Model Hello World<a class="headerlink" href="#shotgun-model-hello-world" title="Permalink to this headline">¶</a></h3>
<p>A hello world style example would look something like this, assuming this code is inside a
toolkit app:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Import the shotgun_model module from the shotgun utils framework</span>
<span class="n">shotgun_model</span> <span class="o">=</span> <span class="n">tank</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">import_framework</span><span class="p">(</span><span class="s2">&quot;tk-framework-shotgunutils&quot;</span><span class="p">,</span> <span class="s2">&quot;shotgun_model&quot;</span><span class="p">)</span>
<span class="c1"># Set up alias</span>
<span class="n">ShotgunModel</span> <span class="o">=</span> <span class="n">shotgun_model</span><span class="o">.</span><span class="n">ShotgunModel</span>

<span class="c1"># Create a standard Qt Tree View</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QTreeView</span><span class="p">(</span><span class="n">parent_widget</span><span class="p">)</span>

<span class="c1"># Set up our data backend</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">shotgun_model</span><span class="o">.</span><span class="n">SimpleShotgunModel</span><span class="p">(</span><span class="n">parent_widget</span><span class="p">)</span>

<span class="c1"># Tell the view to pull data from the model</span>
<span class="n">view</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="c1"># load all assets from Shotgun</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">entity_type</span><span class="o">=</span><span class="s2">&quot;Asset&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code will create a standard Qt tree view of all assets in Shotgun.</p>
</div>
<div class="section" id="beyond-hello-world">
<h3>Beyond Hello World<a class="headerlink" href="#beyond-hello-world" title="Permalink to this headline">¶</a></h3>
<p>The simple setup outlined above could be extended in the following ways:</p>
<ul class="simple">
<li>If you need more control of how the data is being retrieved, consider instead creating
your own class and derive from <a class="reference internal" href="#shotgun_model.ShotgunModel" title="shotgun_model.ShotgunModel"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModel</span></code></a>. This makes it possible to customize
the shotgun data as it arrives from Shotgun, control the hierarchy grouping and many other
things.</li>
<li>If you want to retrieve results from your view, connect signals to the view&#8217;s selection model.</li>
<li>If you want to cull out items from the model, for example only to show items matching a particular
search criteria, use a Proxy Model (typically <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QSortFilterProxyModel.html#PySide.QtGui.QSortFilterProxyModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QSortFilterProxyModel</span></code></a>).</li>
<li>If you want to control the way items are displayed in the view, consider using the Shotgun delegates
module which is part of the Qt widgets framework. For more information, see
<a class="reference external" href="http://developer.shotgunsoftware.com/tk-framework-qtwidgets/views.html#views.WidgetDelegate" title="(in tk-framework-qtwidgets vv2.5.15)"><code class="xref py py-class docutils literal"><span class="pre">WidgetDelegate</span></code></a></li>
</ul>
</div>
<div class="section" id="progress-spinner">
<h3>Progress Spinner<a class="headerlink" href="#progress-spinner" title="Permalink to this headline">¶</a></h3>
<p>The model emits several signals at various points in its refresh cycle. If you want a spinner
to pop up to indicate that data is being loaded, simply add a <a class="reference external" href="http://developer.shotgunsoftware.com/tk-framework-qtwidgets/overlay_widget.html#overlay_widget.ShotgunModelOverlayWidget" title="(in tk-framework-qtwidgets vv2.5.15)"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModelOverlayWidget</span></code></a>
between your view and model, like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">overlay_widget</span> <span class="o">=</span> <span class="n">tank</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">import_framework</span><span class="p">(</span><span class="s2">&quot;tk-framework-qtwidgets&quot;</span><span class="p">,</span> <span class="s2">&quot;overlay_widget&quot;</span><span class="p">)</span>

<span class="c1"># once you have created a view and a model, set up an overlay object to</span>
<span class="c1"># track the model&#39;s activity. Whenver the model is loading data,</span>
<span class="c1"># the overlay will show a spinner.</span>

<span class="n">overlay</span> <span class="o">=</span> <span class="n">overlay_widget</span><span class="o">.</span><span class="n">ShotgunModelOverlayWidget</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to refine how the overlay behaves, simply subclass the class above.
This can be useful if you for example want to display a &#8216;no items found&#8217; message whenever
a shotgun query returns zero items.</p>
</div>
<div class="section" id="data-items">
<h3>Data Items<a class="headerlink" href="#data-items" title="Permalink to this headline">¶</a></h3>
<p>The Shotgun Model derives from <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItemModel.html#PySide.QtGui.QStandardItemModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItemModel</span></code></a> which is a base model which managed the storage
of model data inside a collection of <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> objects. Each of these objects have a number of
standard property and so called <em>roles</em>, holding various pieces of data such as icons, colors etc.
The Shotgun Model introduces two new standard roles which can be used by both subclassing and calling
code:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ShotgunModel.SG_DATA_ROLE</span></code> holds the shotgun data associated with an object. In a tree view, only
leaf nodes have this data defined - other nodes have it set to None. For leaf nodes, it is a standard
shotgun dictionary containing all the items that were returned by the Shotgun query.</li>
<li><code class="docutils literal"><span class="pre">ShotgunModel.SG_ASSOCIATED_FIELD_ROLE</span></code> holds the associated field value for a node. This is contained
in a dictionary with the keys name and value. For example, for a leaf node this is typically something
like <code class="docutils literal"><span class="pre">{&quot;name&quot;:</span> <span class="pre">&quot;code&quot;,</span> <span class="pre">&quot;value&quot;:</span> <span class="pre">&quot;AAA_123&quot;}</span></code>. For an intermediate node, it may be something such as
<code class="docutils literal"><span class="pre">{&quot;name&quot;:</span> <span class="pre">&quot;sg_sequence&quot;,</span> <span class="pre">&quot;value&quot;:</span> <span class="pre">{&quot;id&quot;:</span> <span class="pre">123,</span> <span class="pre">&quot;name&quot;:</span> <span class="pre">&quot;AAA&quot;,</span> <span class="pre">&quot;type&quot;:</span> <span class="pre">&quot;Sequence&quot;}</span> <span class="pre">}</span></code>.</li>
</ul>
</div>
</div>
<div class="section" id="simpleshotgunmodel">
<h2>SimpleShotgunModel<a class="headerlink" href="#simpleshotgunmodel" title="Permalink to this headline">¶</a></h2>
<p>Convenience wrapper around the Shotgun model for quick and easy access. Use this when you want
to prototype data modeling or if your are looking for a simple flat data set reflecting a
shotgun query. All you need to do is to instantiate the class (typically once, in your constructor)
and then call <a class="reference internal" href="#shotgun_model.SimpleShotgunModel.load_data" title="shotgun_model.SimpleShotgunModel.load_data"><code class="xref py py-meth docutils literal"><span class="pre">SimpleShotgunModel.load_data()</span></code></a> to
specify which shotgun query to load up in the model. Subsequently call
<a class="reference internal" href="#shotgun_model.SimpleShotgunModel.load_data" title="shotgun_model.SimpleShotgunModel.load_data"><code class="xref py py-meth docutils literal"><span class="pre">load_data()</span></code></a> whenever you
wish to change the Shotgun query associated with the model.</p>
<p>This class derives from <a class="reference internal" href="#shotgun_model.ShotgunModel" title="shotgun_model.ShotgunModel"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModel</span></code></a> so all the
customization methods available in the
normal ShotgunModel can also be subclassed from this class.</p>
<dl class="class">
<dt id="shotgun_model.SimpleShotgunModel">
<em class="property">class </em><code class="descclassname">shotgun_model.</code><code class="descname">SimpleShotgunModel</code><span class="sig-paren">(</span><em>parent</em>, <em>bg_task_manager=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/simple_shotgun_model.html#SimpleShotgunModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.SimpleShotgunModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">shotgun_model.shotgun_model.ShotgunModel</span></code></p>
<p>Convenience wrapper around the Shotgun model for quick and easy access.</p>
<p>Use this when you want to prototype data modeling or if your are looking 
for a simple flat data set reflecting a shotgun query. All you need to do 
is to instantiate the class (typically once, in your constructor) and then 
call <a class="reference internal" href="#shotgun_model.SimpleShotgunModel.load_data" title="shotgun_model.SimpleShotgunModel.load_data"><code class="xref py py-meth docutils literal"><span class="pre">load_data()</span></code></a> to specify which shotgun query to load up in the model. 
Subsequently call <a class="reference internal" href="#shotgun_model.SimpleShotgunModel.load_data" title="shotgun_model.SimpleShotgunModel.load_data"><code class="xref py py-meth docutils literal"><span class="pre">load_data()</span></code></a> whenever you wish to change the Shotgun 
query associated with the model.</p>
<p>This class derives from <a class="reference internal" href="#shotgun_model.ShotgunModel" title="shotgun_model.ShotgunModel"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModel</span></code></a> so all the customization methods 
available in the normal <a class="reference internal" href="#shotgun_model.ShotgunModel" title="shotgun_model.ShotgunModel"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModel</span></code></a> can also be subclassed from this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parent</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QWidget.html#PySide.QtGui.QWidget" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QWidget</span></code></a>) &#8211; QWidget which this model will be parented under.</li>
<li><strong>bg_task_manager</strong> (<a class="reference internal" href="task_manager.html#task_manager.BackgroundTaskManager" title="task_manager.BackgroundTaskManager"><code class="xref py py-class docutils literal"><span class="pre">BackgroundTaskManager</span></code></a>) &#8211; Background task manager to use for any asynchronous work.  If
this is None then a task manager will be created as needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="shotgun_model.SimpleShotgunModel.load_data">
<code class="descname">load_data</code><span class="sig-paren">(</span><em>entity_type</em>, <em>filters=None</em>, <em>fields=None</em>, <em>order=None</em>, <em>limit=None</em>, <em>columns=None</em>, <em>additional_filter_presets=None</em>, <em>editable_columns=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/simple_shotgun_model.html#SimpleShotgunModel.load_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.SimpleShotgunModel.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads shotgun data into the model, using the cache if possible.
The model is not nested and the first field that is specified
via the fields parameter (<code class="docutils literal"><span class="pre">code</span></code> by default) will be used as the default
name for all model items.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entity_type</strong> &#8211; Shotgun Entity Type to load data for</li>
<li><strong>filters</strong> &#8211; Shotgun API find-style filter list. If no list is specified, all records
for the given entity type will be retrieved.</li>
<li><strong>fields</strong> &#8211; List of Shotgun fields to retrieve. If not spefified, the &#8216;code&#8217; field
will be retrieved.</li>
<li><strong>order</strong> &#8211; Order clause for the Shotgun data. Standard Shotgun API syntax.
Note that this is an advanced parameter which is meant to be used
in subclassing only. The model itself will be ordered by its
default display name, and if any other type of ordering is desirable,
use for example a QProxyModel to handle this. However, knowing in which
order results will arrive from Shotgun can be beneficial if you are doing
grouping, deferred loading and aggregation of data as part of your
subclassed implementation.</li>
<li><strong>limit</strong> &#8211; Limit the number of results returned from Shotgun. In conjunction with the order
parameter, this can be used to effectively cap the data set that the model
is handling, allowing a user to for example show the twenty most recent notes or
similar.</li>
<li><strong>columns</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; List of Shotgun fields names to use to populate the model columns</li>
<li><strong>additional_filter_presets</strong> &#8211; List of Shotgun filter presets to apply, e.g.
<code class="docutils literal"><span class="pre">[{&quot;preset_name&quot;:&quot;LATEST&quot;,&quot;latest_by&quot;:&quot;BY_PIPELINE_STEP_NUMBER_AND_ENTITIES_CREATED_AT&quot;}]</span></code></li>
<li><strong>editable_columns</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; A subset of <code class="docutils literal"><span class="pre">columns</span></code> that will be editable in views that use this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shotgunentitymodel">
<h2>ShotgunEntityModel<a class="headerlink" href="#shotgunentitymodel" title="Permalink to this headline">¶</a></h2>
<p>Another convenience wrapper around the <a class="reference internal" href="#shotgun_model.ShotgunModel" title="shotgun_model.ShotgunModel"><code class="xref py py-class docutils literal"><span class="pre">ShotgunModel</span></code></a>. This model is useful when you
want to represent a tree view of Sequences, Shots or Assets. By default, the model will
associate standard dark-style Shotgun entity type icons to items in the list.</p>
<dl class="class">
<dt id="shotgun_model.ShotgunEntityModel">
<em class="property">class </em><code class="descclassname">shotgun_model.</code><code class="descname">ShotgunEntityModel</code><span class="sig-paren">(</span><em>entity_type</em>, <em>filters</em>, <em>hierarchy</em>, <em>fields</em>, <em>parent</em>, <em>download_thumbs=False</em>, <em>schema_generation=0</em>, <em>bg_load_thumbs=True</em>, <em>bg_task_manager=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_entity_model.html#ShotgunEntityModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunEntityModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">shotgun_model.shotgun_model.ShotgunModel</span></code></p>
<p>A model that contains a hierarchy of Shotgun entity data and sets the icon for each item
to the icon for the entity type if available.</p>
<p>For Step entities, the icon will be a colour swatch based on the Step color field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entity_type</strong> &#8211; The type of the entities that should be loaded into this model.</li>
<li><strong>filters</strong> &#8211; A list of filters to be applied to entities in the model - these 
will be passed to the Shotgun API find() call when populating the 
model</li>
<li><strong>hierarchy</strong> &#8211; List of Shotgun fields that will be used to define the structure 
of the items in the model.</li>
<li><strong>fields</strong> &#8211; List of Shotgun fields to populate the items in the model with.
These will be passed to the Shotgun API find() call when populating
the model.</li>
<li><strong>parent</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QWidget.html#PySide.QtGui.QWidget" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QWidget</span></code></a>) &#8211; Parent QObject.</li>
<li><strong>download_thumbs</strong> &#8211; Boolean to indicate if this model should attempt
to download and process thumbnails for the downloaded data.</li>
<li><strong>schema_generation</strong> &#8211; Schema generation index. If you are changing the format
of the data you are retrieving from Shotgun, and therefore
want to invalidate any cache files that may already exist
in the system, you can increment this integer.</li>
<li><strong>bg_load_thumbs</strong> &#8211; If set to True, thumbnails will be loaded in the background.</li>
<li><strong>bg_task_manager</strong> (<a class="reference internal" href="task_manager.html#task_manager.BackgroundTaskManager" title="task_manager.BackgroundTaskManager"><code class="xref py py-class docutils literal"><span class="pre">BackgroundTaskManager</span></code></a>) &#8211; Background task manager to use for any asynchronous work.  If
this is None then a task manager will be created as needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="shotgun_model.ShotgunEntityModel.get_entity_icon">
<code class="descname">get_entity_icon</code><span class="sig-paren">(</span><em>entity_type</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_entity_model.html#ShotgunEntityModel.get_entity_icon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunEntityModel.get_entity_icon" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method. Retrieve the icon for the specified entity type if available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>entity_type</strong> &#8211; The entity type to retrieve the icon for</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A QIcon if an icon was found for the specified entity
type, otherwise None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunEntityModel.get_entities">
<code class="descname">get_entities</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_entity_model.html#ShotgunEntityModel.get_entities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunEntityModel.get_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get entities for the current item by traversing up the tree and pulling entity information 
from each item if possible</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a>) &#8211; The item to find entities for.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of Shotgun entity dictionaries in the order they were found starting from
the specified item.  Each dictionary will contain all the entity information stored
by the model which is usually determined by the list of fields passed during 
construction plus name/code, type and id.<p>For non-leaf items that represent Shotgun entities, the dictionary will typically
just contain name, type and id.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunEntityModel.get_entity">
<code class="descname">get_entity</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_entity_model.html#ShotgunEntityModel.get_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunEntityModel.get_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Shotgun entity details for the specified model item.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a>) &#8211; The item to retrieve the entity details for.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Shotgun entity dictionary for the item if it represents an entity, otherwise 
None.  The dictionary will contain all the entity information stored by the model 
which is usually determined by the list of fields passed during construction plus
name/code, type and id.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunEntityModel.async_refresh">
<code class="descname">async_refresh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_entity_model.html#ShotgunEntityModel.async_refresh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunEntityModel.async_refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger an asynchronous refresh of the model</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shotgunmodel">
<h2>ShotgunModel<a class="headerlink" href="#shotgunmodel" title="Permalink to this headline">¶</a></h2>
<p>A Qt Model representing a Shotgun query.</p>
<p>This class implements a standard <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtCore/QAbstractItemModel.html#PySide.QtCore.QAbstractItemModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QAbstractItemModel</span></code></a> specialized to hold the contents
of a particular Shotgun query. It is cached and refreshes its data asynchronously.</p>
<p>The model can either be a flat list or a tree. This is controlled by a grouping
parameter which works just like the Shotgun grouping. For example, if you pull
in assets grouped by asset type, you get a tree of data with intermediate data
types for the asset types. The leaf nodes in this case would be assets.</p>
<dl class="class">
<dt id="shotgun_model.ShotgunModel">
<em class="property">class </em><code class="descclassname">shotgun_model.</code><code class="descname">ShotgunModel</code><span class="sig-paren">(</span><em>parent</em>, <em>download_thumbs=True</em>, <em>schema_generation=0</em>, <em>bg_load_thumbs=True</em>, <em>bg_task_manager=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel" title="Permalink to this definition">¶</a></dt>
<dd><p>A Qt Model representing a Shotgun query.</p>
<p>This class implements a standard <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtCore/QAbstractItemModel.html#PySide.QtCore.QAbstractItemModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QAbstractItemModel</span></code></a>
specialized to hold the contents of a particular Shotgun query. It is cached
and refreshes its data asynchronously.</p>
<p>In order to use this class, you normally subclass it and implement certain key data
methods for setting up queries, customizing etc. Then you connect your class to
a <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QAbstractItemView.html#PySide.QtGui.QAbstractItemView" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QAbstractItemView</span></code></a> of some sort which will display the result.
If you need to do manipulations such as sorting or filtering on the data,
connect a proxy model (typically <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QSortFilterProxyModel.html#PySide.QtGui.QSortFilterProxyModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QSortFilterProxyModel</span></code></a>)
between your class and the view.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parent</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QWidget.html#PySide.QtGui.QWidget" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QWidget</span></code></a>) &#8211; Parent object.</li>
<li><strong>download_thumbs</strong> &#8211; Boolean to indicate if this model should attempt
to download and process thumbnails for the downloaded data.</li>
<li><strong>schema_generation</strong> &#8211; Schema generation number. Advanced parameter. If your
shotgun model contains logic in subclassed methods
that modify the shotgun data prior to it being put into
the cache system that the ShotgunModel maintains, you can
use this option to ensure that different versions of the code
access different caches. If you change your custom business logic
around and update the generation number, both new and old
versions of the code will work correctly against the cached data.</li>
<li><strong>bg_load_thumbs</strong> &#8211; If set to True, thumbnails will be loaded in the background.</li>
<li><strong>bg_task_manager</strong> (<a class="reference internal" href="task_manager.html#task_manager.BackgroundTaskManager" title="task_manager.BackgroundTaskManager"><code class="xref py py-class docutils literal"><span class="pre">BackgroundTaskManager</span></code></a>) &#8211; Background task manager to use for any asynchronous work. If
this is None then a task manager will be created as needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Loading &amp; Refreshing the Data</strong></p>
<p>These methods are used by subclasses to define the Shotgun query that loads
and caches the model items and refreshes them once cached.</p>
<dl class="method">
<dt id="shotgun_model.ShotgunModel._load_data">
<code class="descname">_load_data</code><span class="sig-paren">(</span><em>entity_type</em>, <em>filters</em>, <em>hierarchy</em>, <em>fields</em>, <em>order=None</em>, <em>seed=None</em>, <em>limit=None</em>, <em>columns=None</em>, <em>additional_filter_presets=None</em>, <em>editable_columns=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._load_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main method to use to configure the model. You basically
pass a specific find query to the model and it will start tracking
this particular set of filter and hierarchy parameters.</p>
<p>Any existing data contained in the model will be cleared.</p>
<p>This method will not call the Shotgun API. If cached data is available,
this will be immediately loaded (this operation is very fast even for
substantial amounts of data).</p>
<p>If you want to refresh the data contained in the model (which you typically
want to), call the <a class="reference internal" href="#shotgun_model.ShotgunModel._refresh_data" title="shotgun_model.ShotgunModel._refresh_data"><code class="xref py py-meth docutils literal"><span class="pre">_refresh_data()</span></code></a> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Example call from a subclass of ShotgunModel that displays assets.</span>
<span class="c1"># Additional &quot;code&quot; and &quot; description&quot; columns will be displayed,</span>
<span class="c1"># and the &quot;description&quot; column will be editable.</span>
<span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span>
    <span class="s2">&quot;Asset&quot;</span><span class="p">,</span>                            <span class="c1"># entity_type</span>
    <span class="p">[],</span>                                 <span class="c1"># filters</span>
    <span class="p">[</span><span class="s2">&quot;sg_asset_type&quot;</span><span class="p">,</span> <span class="s2">&quot;code&quot;</span><span class="p">],</span>          <span class="c1"># hierarchy</span>
    <span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">],</span>                    <span class="c1"># fields</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">],</span>    <span class="c1"># additional columns to display</span>
    <span class="n">editable_columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> &#8211; Shotgun entity type to download</li>
<li><strong>filters</strong> &#8211; List of Shotgun filters. Standard Shotgun syntax. Passing None instead
of a list of filters indicates that no shotgun data should be retrieved
and no API calls will be made.</li>
<li><strong>hierarchy</strong> &#8211; List of grouping fields. These should be names of Shotgun
fields. If you for example want to create a list of items,
the value <code class="docutils literal"><span class="pre">[&quot;code&quot;]</span></code> will be suitable. This will generate a data
model which is flat and where each item&#8217;s default name is the
Shotgun name field. If you want to generate a tree where assets
are broken down by asset type, you could instead specify
<code class="docutils literal"><span class="pre">[&quot;sg_asset_type&quot;,</span> <span class="pre">&quot;code&quot;]</span></code>.</li>
<li><strong>fields</strong> &#8211; Fields to retrieve from Shotgun (in addition to the ones specified
in the hierarchy parameter). Standard Shotgun API syntax. If you
specify None for this parameter, Shotgun will not be called when
the _refresh_data() method is being executed.</li>
<li><strong>order</strong> &#8211; Order clause for the Shotgun data. Standard Shotgun API syntax.
Note that this is an advanced parameter which is meant to be used
in subclassing only. The model itself will be ordered by its
default display name, and if any other type of ordering is desirable,
use for example a QProxyModel to handle this. However, knowing in which
order results will arrive from Shotgun can be beneficial if you are doing
grouping, deferred loading and aggregation of data as part of your
subclassed implementation, typically via the <a class="reference internal" href="#shotgun_model.ShotgunModel._before_data_processing" title="shotgun_model.ShotgunModel._before_data_processing"><code class="xref py py-meth docutils literal"><span class="pre">_before_data_processing()</span></code></a> method.</li>
<li><strong>seed</strong> &#8211; Advanced parameter. With each shotgun query being cached on disk, the model
generates a cache seed which it is using to store data on disk. Since the cache
data on disk is a reflection of a particular shotgun query, this seed is typically
generated from the various query and field parameters passed to this method. However,
in some cases when you are doing advanced subclassing, for example when you are culling
out data based on some external state, the model state does not solely depend on the
shotgun query parameters. It may also depend on some external factors. In this case,
the cache seed should also be influenced by those parameters and you can pass
an external string via this parameter which will be added to the seed.</li>
<li><strong>limit</strong> &#8211; Limit the number of results returned from Shotgun. In conjunction with the order
parameter, this can be used to effectively cap the data set that the model
is handling, allowing a user to for example show the twenty most recent notes or
similar.</li>
<li><strong>columns</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; If columns is specified, then any leaf row in the model will have columns created where
each column in the row contains the value for the corresponding field from columns. This means
that the data from the loaded entity will be available field by field. Subclasses can modify
this behavior by overriding _get_additional_columns.</li>
<li><strong>additional_filter_presets</strong> &#8211; List of Shotgun filter presets to apply, e.g.
<code class="docutils literal"><span class="pre">[{&quot;preset_name&quot;:&quot;LATEST&quot;,&quot;latest_by&quot;:&quot;BY_PIPELINE_STEP_NUMBER_AND_ENTITIES_CREATED_AT&quot;}]</span></code></li>
<li><strong>editable_columns</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; A subset of <code class="docutils literal"><span class="pre">columns</span></code> that will be editable in views that use this model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if cached data was loaded, False if not.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._refresh_data">
<code class="descname">_refresh_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._refresh_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._refresh_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuilds the data in the model to ensure it is up to date.
This call is asynchronous and will return instantly.
The update will be applied whenever the data from Shotgun is returned.</p>
<p>If the model is empty (no cached data) no data will be shown at first
while the model fetches data from Shotgun.</p>
<p>As soon as a local cache exists, data is shown straight away and the
shotgun update happens silently in the background.</p>
<p>If data has been added, this will be injected into the existing structure.
In this case, the rest of the model is intact, meaning that also selections
and other view related states are unaffected.</p>
<p>If data has been modified or deleted, a full rebuild is issued, meaning that
all existing items from the model are removed. This does affect view related
states such as selection.</p>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.ensure_data_is_loaded">
<code class="descname">ensure_data_is_loaded</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.ensure_data_is_loaded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.ensure_data_is_loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively processes the model and ensures that all data
has been loaded into the model.</p>
<p>Beginning with v5, the Shotgun model defer loads its data into the model for
optimal performance. Normally, this is not an issue - the data is typically
requested prior to a user expanding a tree node in a view. In some cases,
however, it is necessary to pre-fetch parts of the tree. One example of this
is if you want to perform filtering via a
<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QSortFilterProxyModel.html#PySide.QtGui.QSortFilterProxyModel" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QSortFilterProxyModel</span></code></a>. Please note that for large
data sets, this operation may be slow.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 5.0.0.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtCore/QModelIndex.html#PySide.QtCore.QModelIndex" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QModelIndex</span></code></a>) &#8211; Model index for which to recursively load data.
If set to None, the entire tree will be loaded.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method prior to destroying this object.</p>
<p>Base implementation ensures the data worker is stopped and calls
<code class="docutils literal"><span class="pre">clear()</span></code> on the model.</p>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.hard_refresh">
<code class="descname">hard_refresh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel.hard_refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears any caches on disk, then refreshes the data.</p>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.is_data_cached">
<code class="descname">is_data_cached</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel.is_data_cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the model has any cached data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if cached data exists for the model, <code class="docutils literal"><span class="pre">False</span></code>
otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><strong>Customizing the Model Items</strong></p>
<p>The following methods can be used by subclasses to customize the model
and the information it displays when attached to a view.</p>
<dl class="method">
<dt id="shotgun_model.ShotgunModel._before_data_processing">
<code class="descname">_before_data_processing</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._before_data_processing" title="Permalink to this definition">¶</a></dt>
<dd><p>Called just after data has been retrieved from Shotgun but before any
processing takes place.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can subclass this if you want to perform summaries,
calculations and other manipulations of the data before it is
passed on to the model class.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; a shotgun dictionary, as retunrned by a CRUD SG API call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">should return a shotgun dictionary, of the same form as the
input.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._finalize_item">
<code class="descname">_finalize_item</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._finalize_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever an item is fully constructed, either because a shotgun
query returned it or because it was loaded as part of a cache load from
disk.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can subclass this if you want to run post processing on
the data as it is arriving. For example, if you are showing a list
of task statuses in a filter view, you may want to remember which
statuses a user had checked and unchecked the last time he was
running the tool. By subclassing this method you can easily apply
those settings before items appear in the UI.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> that is about to be
added to the model.  This has been primed with the standard settings
that the ShotgunModel handles.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._get_additional_columns">
<code class="descname">_get_additional_columns</code><span class="sig-paren">(</span><em>primary_item</em>, <em>is_leaf</em>, <em>columns</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._get_additional_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._get_additional_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an item is about to be inserted into the model, to get additional items
to be included in the same row as the specified item. This provides an opportunity
for subclasses to create one or more additional columns for each item in the model.</p>
<p>Note that this method is always called before inserting an item, even when loading
from the cache. Any data that is expensive to compute or query should be added
to the ShotgunStandardItem in _populate_item, since column data is not cached.
Also note that item population methods (_populate_item, _populate_thumbnail, etc)
will not be called on the return columns.</p>
<p>This method should return a list of QStandardItems, one for each additional column.
The original ShotgunStandardItem is always the first item in each row and should
NOT be included in the returned list. Any empty value returned by this method
is guaranteed to be treated as an empty list (i.e. you may return None).</p>
<p>This method is called after _finalize_item.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>primary_item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> that is about to be added to the model</li>
<li><strong>is_leaf</strong> &#8211; boolean that is True if the item is a leaf item</li>
<li><strong>columns</strong> &#8211; list of Shotgun field names requested as the columns from _load_data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._get_additional_column_headers">
<code class="descname">_get_additional_column_headers</code><span class="sig-paren">(</span><em>entity_type</em>, <em>columns</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._get_additional_column_headers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._get_additional_column_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to set the headers for the additional columns requested from _load_data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> &#8211; type name of the entity the columns are for</li>
<li><strong>columns</strong> &#8211; list of Shotgun field names requested as the columns from _load_data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of strings to use as the headers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._get_columns">
<code class="descname">_get_columns</code><span class="sig-paren">(</span><em>item</em>, <em>is_leaf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._get_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._get_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a row (list of QStandardItems) given an initial QStandardItem.  The item itself
is always the first item in the row, but additional columns may be appended.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>item</strong> &#8211; A <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> that is associated with this model.</li>
<li><strong>is_leaf</strong> &#8211; A boolean indicating if the item is a leaf item or not</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> s</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._item_created">
<code class="descname">_item_created</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._item_created"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._item_created" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an item is created, before it is added to the model.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This base class implementation must be called in any
subclasses overriding this behavior. Failure to do so will result in
unexpected behavior.</p>
</div>
<p>This base class implementation handles storing item lookups for
efficiency as well as to prevent issues with garbage collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> (<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a>) &#8211; The item that was just created.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._load_external_data">
<code class="descname">_load_external_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._load_external_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the model needs to be rebuilt from scratch. This is
called prior to any shotgun data is added to the model.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can subclass this to add custom data to the model in a
very flexible fashion. If you for example are loading published
files from Shotgun, you could use this to load up a listing of
files on disk, resulting in a model that shows both published files
and local files.  External data will not be cached by the
ShotgunModel framework.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._populate_default_thumbnail">
<code class="descname">_populate_default_thumbnail</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._populate_default_thumbnail" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever an item is constructed and needs to be associated with
a default thumbnail.  In the current implementation, thumbnails are not
cached in the same way as the rest of the model data, meaning that this
method is executed each time an item is constructed, regardless of if
it came from an asynchronous shotgun query or a cache fetch.</p>
<p>The purpose of this method is that you can subclass it if you want to
ensure that items have an associated thumbnail directly when they are
first created.</p>
<p>Later on in the data load cycle, if the model was instantiated with the
<cite>download_thumbs</cite> parameter set to True, the standard Shotgun <code class="docutils literal"><span class="pre">image</span></code>
field thumbnail will be automatically downloaded for all items (or
picked up from local cache if possible).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> that is about to be
added to the model.  This has been primed with the standard
settings that the ShotgunModel handles.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._populate_item">
<code class="descname">_populate_item</code><span class="sig-paren">(</span><em>item</em>, <em>sg_data</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._populate_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Whenever an item is downloaded from Shotgun, this method is called. It
allows subclasses to intercept the construction of a
<a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> and add additional metadata or
make other changes that may be useful. Nothing needs to be returned.</p>
<p>This method is called before the item is added into the model tree. At
the point when the item is added into the tree, various signals will
fire, informing views and proxy models that a new item has been added.
This methods allows a subclassing object to add custom data prior to
this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> that is about to be
added to the model.</li>
<li><strong>sg_data</strong> &#8211; Shotgun data dictionary that was received from Shotgun.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._populate_thumbnail">
<code class="descname">_populate_thumbnail</code><span class="sig-paren">(</span><em>item</em>, <em>field</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenever the real thumbnail for an item exists on disk. The following
execution sequence typically happens:</p>
<ul class="simple">
<li><a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> is created, either through a cache load from disk or
from a payload coming from the Shotgun API.</li>
<li>After the item has been set up with its associated Shotgun data,
<a class="reference internal" href="#shotgun_model.ShotgunModel._populate_default_thumbnail" title="shotgun_model.ShotgunModel._populate_default_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_default_thumbnail()</span></code></a> is called, allowing client code to set
up a default thumbnail that will be shown while potential real thumbnail
data is being loaded.</li>
<li>The model will now start looking for the real thumbail.</li>
<li>If the thumbnail is already cached on disk, <a class="reference internal" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="shotgun_model.ShotgunModel._populate_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_thumbnail()</span></code></a> is called very soon.</li>
<li>If there isn&#8217;t a thumbnail associated, <a class="reference internal" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="shotgun_model.ShotgunModel._populate_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_thumbnail()</span></code></a> will not be called.</li>
<li>If there isn&#8217;t a thumbnail cached, the model will asynchronously download
the thumbnail from Shotgun and then (after some time) call <a class="reference internal" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="shotgun_model.ShotgunModel._populate_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_thumbnail()</span></code></a>.</li>
</ul>
<p>This method will be called for standard thumbnails if the model has been
instantiated with the download_thumbs flag set to be true. It will be called for
items which are associated with shotgun entities (in a tree data layout, this is typically
leaf nodes). It will also be called once the data requested via _request_thumbnail_download()
arrives.</p>
<p>This method makes it possible to control how the thumbnail is applied and associated
with the item. The default implementation will simply set the thumbnail to be icon
of the item, but this can be altered by subclassing this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> which is associated with the given thumbnail</li>
<li><strong>field</strong> &#8211; The Shotgun field which the thumbnail is associated with.</li>
<li><strong>path</strong> &#8211; A path on disk to the thumbnail. This is a file in jpeg format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._populate_thumbnail_image">
<code class="descname">_populate_thumbnail_image</code><span class="sig-paren">(</span><em>item</em>, <em>field</em>, <em>image</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._populate_thumbnail_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="shotgun_model.ShotgunModel._populate_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_thumbnail()</span></code></a> but this method is called instead
when the bg_load_thumbs parameter has been set to true. In this case, no
loading of thumbnail data from disk is necessary - this has already been
carried out async and is passed in the form of a QImage object.</p>
<p>For further details, see <a class="reference internal" href="#shotgun_model.ShotgunModel._populate_thumbnail" title="shotgun_model.ShotgunModel._populate_thumbnail"><code class="xref py py-meth docutils literal"><span class="pre">_populate_thumbnail()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> which is associated with the given thumbnail</li>
<li><strong>field</strong> &#8211; The Shotgun field which the thumbnail is associated with.</li>
<li><strong>image</strong> &#8211; QImage object with the thumbnail loaded</li>
<li><strong>path</strong> &#8211; A path on disk to the thumbnail. This is a file in jpeg format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._request_thumbnail_download">
<code class="descname">_request_thumbnail_download</code><span class="sig-paren">(</span><em>item</em>, <em>field</em>, <em>url</em>, <em>entity_type</em>, <em>entity_id</em><span class="sig-paren">)</span><a class="headerlink" href="#shotgun_model.ShotgunModel._request_thumbnail_download" title="Permalink to this definition">¶</a></dt>
<dd><p>Request that a thumbnail is downloaded for an item. If a thumbnail is successfully
retrieved, either from disk (cached) or via shotgun, the method _populate_thumbnail()
will be called. If you want to control exactly how your shotgun thumbnail is
to appear in the UI, you can subclass this method. For example, you can subclass
this method and perform image composition prior to the image being added to
the item object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an advanced method which you can use if you want to load thumbnail
data other than the standard &#8216;image&#8217; field. If that&#8217;s what you need, simply make
sure that you set the download_thumbs parameter to true when you create the model
and standard thumbnails will be automatically downloaded. This method is either used
for linked thumb fields or if you want to download thumbnails for external model data
that doesn&#8217;t come from Shotgun.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> &#8211; <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> which belongs to this model</li>
<li><strong>field</strong> &#8211; Shotgun field where the thumbnail is stored. This is typically <code class="docutils literal"><span class="pre">image</span></code> but
can also for example be <code class="docutils literal"><span class="pre">sg_sequence.Sequence.image</span></code>.</li>
<li><strong>url</strong> &#8211; thumbnail url</li>
<li><strong>entity_type</strong> &#8211; Shotgun entity type</li>
<li><strong>entity_id</strong> &#8211; Shotgun entity id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel._set_tooltip">
<code class="descname">_set_tooltip</code><span class="sig-paren">(</span><em>item</em>, <em>sg_item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel._set_tooltip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel._set_tooltip" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when an item is created.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You can subclass this if you want to set your own tooltip for the model item. By
default, the SG_ASSOCIATED_FIELD_ROLE data is retrieved and the field name is used to
determine which field to pick tooltip information from.</p>
<p>For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span>
    <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="p">{</span>                       <span class="c1"># (1) Tooltip becomes &quot;Asset &#39;Alice&#39;&quot;</span>
        <span class="s2">&quot;sg_asset_type&quot;</span><span class="p">:</span> <span class="s2">&quot;Character&quot;</span><span class="p">,</span> <span class="c1"># (2) Tooltip becomes &quot;Asset Type &#39;Character&#39;&quot;</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Asset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;Art&quot;</span>                  <span class="c1"># (3) Tooltip becomes &quot;Task &#39;Art&#39;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>1) If the field is an entity (e.g. entity), then the display name of that entity&#8217;s type
will be used.</p>
<p>2) If the field is part of a sub-entity (e.g entity.Asset.sg_asset_type), the display
name of the sub-entity&#8217;s type followed by a space and the sub-entity&#8217;s field display name
will be used.</p>
<p>3) If the field is part of an entity and not an entity field(e.g. content), the display
name of the entity&#8217;s type will be used.</p>
<p class="last">In all cases, the string ends with the quoted name of the ShotgunStandardItem.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> &#8211; Shotgun model item that requires a tooltip.</li>
<li><strong>sg_item</strong> &#8211; Dictionary of the entity associated with the Shotgun model item.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><strong>Instance Methods</strong></p>
<dl class="attribute">
<dt id="shotgun_model.ShotgunModel.entity_ids">
<code class="descname">entity_ids</code><a class="headerlink" href="#shotgun_model.ShotgunModel.entity_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of entity ids that are part of this model.</p>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.item_from_entity">
<code class="descname">item_from_entity</code><span class="sig-paren">(</span><em>entity_type</em>, <em>entity_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.item_from_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.item_from_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> based on
entity type and entity id. Returns none if not found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> &#8211; Shotgun entity type to look for</li>
<li><strong>entity_id</strong> &#8211; Shotgun entity id to look for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> or None if not found</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.index_from_entity">
<code class="descname">index_from_entity</code><span class="sig-paren">(</span><em>entity_type</em>, <em>entity_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.index_from_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.index_from_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a QModelIndex based on entity type and entity id
Returns none if not found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> &#8211; Shotgun entity type to look for</li>
<li><strong>entity_id</strong> &#8211; Shotgun entity id to look for</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtCore/QModelIndex.html#PySide.QtCore.QModelIndex" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QModelIndex</span></code></a> or None if not found</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.get_filters">
<code class="descname">get_filters</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.get_filters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.get_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Shotgun filters representing the given item. This is useful if
you are trying to determine how intermediate leaf nodes partition leaf node data.</p>
<p>For example, if you have created a hierarchical model for a Shot listing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">hierarchy</span><span class="p">:</span> <span class="p">[</span><span class="n">sg_sequence</span><span class="p">,</span> <span class="n">sg_status</span><span class="p">,</span> <span class="n">code</span><span class="p">]</span>
</pre></div>
</div>
<p>The Shotgun model will group the data by sequence, then by status, then the leaf
nodes will be the shot names. If you execute the get_filters() method on a sequence
level tree node, it may return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="p">[</span><span class="s1">&#39;sg_sequence&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}]</span> <span class="p">]</span>
</pre></div>
</div>
<p>If you execute the get_filters() on a status node in the tree, it may return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span>
  <span class="p">[</span><span class="s1">&#39;sg_sequence&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}],</span>
  <span class="p">[</span><span class="s1">&#39;sg_status&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="s1">&#39;ip&#39;</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> &#8211; One of the <a class="reference external" href="http://pyside.github.io/docs/pyside/PySide/QtGui/QStandardItem.html#PySide.QtGui.QStandardItem" title="(in PySide v1.2.1)"><code class="xref py py-class docutils literal"><span class="pre">QStandardItem</span></code></a> items that are associated with this model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">standard shotgun filter list to represent that item</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.get_entity_type">
<code class="descname">get_entity_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.get_entity_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.get_entity_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Shotgun Entity type associated with this model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Shotgun entity type string (e.g. &#8216;Shot&#8217;, &#8216;Asset&#8217; etc).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="shotgun_model.ShotgunModel.get_additional_column_fields">
<code class="descname">get_additional_column_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/shotgun_model/shotgun_model.html#ShotgunModel.get_additional_column_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#shotgun_model.ShotgunModel.get_additional_column_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fields for additional columns and their associated column in the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of dictionaries with the following keys:
&#8220;field&#8221;: the requested additional field for the column
&#8220;column_idx&#8221;: the column number in the model associated with the additional field</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="shotgun_hierarchy_model.html" class="btn btn-neutral float-right" title="Shotgun Hierarchy Model" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="The Shotgun Utilities Framework" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Autodesk.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'v5.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2114792-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>