



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>shotgun_data.shotgun_data_retriever &mdash; tk-framework-shotgunutils v5.8.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          
    <a href='http://developer.shotgridsoftware.com'>
    
        <img style='width: 191px;
                height: 60px;
                margin: 2px;
                border-radius: 0px;
                padding: 0px;'
            src='../../_static/logo@2x.png'/>
    
    </a>
    

          
            <a href="../../index.html" class="icon icon-home"> tk-framework-shotgunutils
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../shotgun_model.html">Shotgun Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shotgun_hierarchy_model.html">Shotgun Hierarchy Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shotgun_data.html">Shotgun Asynchronous Data Retriever</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../task_manager.html">Background Task Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../settings.html">Shotgun Toolkit Qt Settings Wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shotgun_globals.html">Shotgun Globals Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../external_config.html">External Configuration Management</a></li>
</ul>

            
          

    <a href='genindex.html'>Alphabetic Index</a>

    <div style='margin-top: 50px;
                margin-left: 10px;
                margin-right: 10px;
                padding: 10px;
                color: #b3b3b3;
                font-size: 70%;
                border-radius: 3px;
                background-color: #444;
                line-height: 18px;
                '>
    <style>
        a.custom_post_menu { display: inline;
                             padding: 0px;
                             text-decoration: underline; }
    </style>

    <b>tk-framework-shotgunutils</b> v5.8.1.<br>
    
        This documentation is part of the Shotgun Pipeline Toolkit.
    
    For more information, please visit
    <a class=custom_post_menu href='https://support.shotgridsoftware.com/home'>Shotgun Support</a>.
    The code associated with this documentation can be found
    <a class=custom_post_menu href='https://github.com/shotgunsoftware/tk-framework-shotgunutils'>here</a>.

    </div>



        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tk-framework-shotgunutils</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>shotgun_data.shotgun_data_retriever</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for shotgun_data.shotgun_data_retriever</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2015 Shotgun Software Inc.</span>
<span class="c1">#</span>
<span class="c1"># CONFIDENTIAL AND PROPRIETARY</span>
<span class="c1">#</span>
<span class="c1"># This work is provided &quot;AS IS&quot; and subject to the Shotgun Pipeline Toolkit</span>
<span class="c1"># Source Code License included in this distribution package. See LICENSE.</span>
<span class="c1"># By accessing, using, copying or modifying this work you indicate your</span>
<span class="c1"># agreement to the Shotgun Pipeline Toolkit Source Code License. All rights</span>
<span class="c1"># not expressly granted therein are reserved by Shotgun Software Inc.</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">tank_vendor</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="kn">import</span> <span class="nn">sgtk</span>
<span class="kn">from</span> <span class="nn">sgtk.platform.qt</span> <span class="kn">import</span> <span class="n">QtCore</span><span class="p">,</span> <span class="n">QtGui</span>
<span class="kn">from</span> <span class="nn">sgtk</span> <span class="kn">import</span> <span class="n">TankError</span>


<span class="k">def</span> <span class="nf">_indicate_resource_accessed</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper to indicate a resource was accessed and shouldn&#39;t be considered</span>
<span class="sd">    old when cleaning up old cached data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">utime</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<div class="viewcode-block" id="ShotgunDataRetriever"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever">[docs]</a><span class="k">class</span> <span class="nc">ShotgunDataRetriever</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asynchronous data retriever class which can be used to retrieve data and</span>
<span class="sd">    thumbnails from Shotgun and from disk thumbnail cache. Uses the</span>
<span class="sd">    :class:`~task_manager.BackgroundTaskManager` to run tasks in background</span>
<span class="sd">    threads and emits signals when each query has either completed or failed.</span>
<span class="sd">    Requests are queued up using for example the :meth:`execute_find()` and</span>
<span class="sd">    :meth:`request_thumbnail()` methods.</span>

<span class="sd">    Requests are executed in the following priority order:</span>

<span class="sd">    - First any thumbnails that are already cached on disk are handled.</span>
<span class="sd">    - Next, shotgun find() queries are handled.</span>
<span class="sd">    - Lastly thumbnail downloads are handled.</span>

<span class="sd">    The thread will emit work_completed and work_failure signals when</span>
<span class="sd">    tasks are completed (or fail). The :meth:`clear()` method will</span>
<span class="sd">    clear the current queue. The currently processing item will finish</span>
<span class="sd">    processing and may send out signals even after a clear. Make sure you</span>
<span class="sd">    call the :meth:`stop()` method prior to destruction in order for the</span>
<span class="sd">    system to gracefully shut down.</span>

<span class="sd">    :signal work_completed(uid, request_type, data_dict): Emitted every time</span>
<span class="sd">        a requested task has completed. ``uid`` is a unique id which matches</span>
<span class="sd">        the unique id returned by the corresponding request call.</span>
<span class="sd">        ``request_type`` is a string denoting the type of request this</span>
<span class="sd">        event is associated with. ``data_dict`` is a dictionary containing</span>
<span class="sd">        the payload of the request. It will be different depending on what</span>
<span class="sd">        type of request it is.</span>

<span class="sd">    :signal work_failure(uid, error_message): Emitted every time a requested</span>
<span class="sd">        task has failed. ``uid`` is a unique id which matches the unique</span>
<span class="sd">        id returned by the corresponding request call.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># syntax: work_completed(uid, request_type, data_dict)</span>
    <span class="c1"># - uid is a unique id which matches the unique id</span>
    <span class="c1">#   returned by the corresponding request call.</span>
    <span class="c1">#</span>
    <span class="c1"># - request_type is a string denoting the type of request</span>
    <span class="c1">#   this event is associated with. It can be either &quot;find&quot;</span>
    <span class="c1">#   &quot;find_one&quot;, &quot;update&quot;, &quot;create&quot;, &quot;delete&quot;, &quot;schema&quot;, &quot;expand_nav&quot;</span>
    <span class="c1">#   or &quot;thumbnail&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># - data_dict is a dictionary containing the payload</span>
    <span class="c1">#   of the request. It will be different depending on</span>
    <span class="c1">#   what type of request it is.</span>
    <span class="c1">#</span>
    <span class="c1">#   For find() requests, the data_dict will be on the form</span>
    <span class="c1">#   {&quot;sg&quot;: data }, where data is the data returned by the sg API</span>
    <span class="c1">#</span>
    <span class="c1">#   For thumbnail requests, the data dict will be on the form</span>
    <span class="c1">#   {&quot;thumb_path&quot;: path}, where path is a path to a location</span>
    <span class="c1">#   on disk where the thumbnail can be accessed.</span>
    <span class="n">work_completed</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

    <span class="c1"># syntax: work_failure(uid, error_message)</span>
    <span class="c1"># - uid is a unique id which matches the unique id</span>
    <span class="c1">#   returned by the corresponding request call.</span>
    <span class="c1"># - error message is an error message string.</span>
    <span class="n">work_failure</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Individual task priorities used when adding tasks to the task manager</span>
    <span class="c1"># Note: a higher value means more important and will get run before lower</span>
    <span class="c1"># priority tasks</span>

    <span class="c1"># Attachment checks and downloads are more important than thumbnails,</span>
    <span class="c1"># as having access to that data will often be required instead of as</span>
    <span class="c1"># a nice-to-have. As a result, this gets a bit more priority.</span>
    <span class="n">_CHECK_ATTACHMENT_PRIORITY</span> <span class="o">=</span> <span class="mi">55</span>

    <span class="c1"># thumbnail checks are local disk checks and very fast.  These</span>
    <span class="c1"># are always carried out before any shotgun calls</span>
    <span class="n">_CHECK_THUMB_PRIORITY</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="c1"># the shotgun schema is often useful to have as early on as possible,</span>
    <span class="c1"># sometimes other shotgun operations also need the shotgun schema</span>
    <span class="c1"># (and it&#39;s typically also cached) so this call has a higher priority</span>
    <span class="c1"># than the rest of the shotgun calls</span>
    <span class="n">_SG_DOWNLOAD_SCHEMA_PRIORITY</span> <span class="o">=</span> <span class="mi">40</span>

    <span class="c1"># next the priority for any other Shotgun calls (e.g. find, create,</span>
    <span class="c1"># update, delete, etc.)</span>
    <span class="n">_SG_CALL_PRIORITY</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="c1"># Attachment downloads are not necessarily fast (but might be), but unlike</span>
    <span class="c1"># thumbnails they will be required for functionality in the calling code.</span>
    <span class="c1"># As such, we&#39;ll give these downloads a bit more priority.</span>
    <span class="n">_DOWNLOAD_ATTACHMENT_PRIORITY</span> <span class="o">=</span> <span class="mi">25</span>

    <span class="c1"># thumbnails are downloaded last as they are considered low-priority</span>
    <span class="c1"># and can take a relatively significant amount of time</span>
    <span class="n">_DOWNLOAD_THUMB_PRIORITY</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bg_task_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param parent: Parent object</span>
<span class="sd">        :type parent: :class:`~PySide.QtGui.QWidget`</span>
<span class="sd">        :param sg: Optional Shotgun API Instance</span>
<span class="sd">        :param bg_task_manager: Optional Task manager</span>
<span class="sd">        :class bg_task_manager: :class:`~task_manager.BackgroundTaskManager`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span> <span class="o">=</span> <span class="n">sgtk</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">current_bundle</span><span class="p">()</span>

        <span class="c1"># set up the background task manager:</span>
        <span class="n">task_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;task_manager&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span> <span class="o">=</span> <span class="n">bg_task_manager</span> <span class="ow">or</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">BackgroundTaskManager</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_threads</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owns_task_manager</span> <span class="o">=</span> <span class="n">bg_task_manager</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">next_group_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">task_completed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_task_completed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">task_failed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_task_failed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">############################################################################################################</span>
    <span class="c1"># Public methods</span>

<div class="viewcode-block" id="ShotgunDataRetriever.download_thumbnail"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.download_thumbnail">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">download_thumbnail</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">bundle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience and compatibility method for quick and easy synchrnous thumbnail download.</span>
<span class="sd">        This will retrieve a shotgun thumbnail given a url - if it already exists in the cache,</span>
<span class="sd">        a path to it will be returned instantly. If not, it will be downloaded from Shotgun,</span>
<span class="sd">        placed in the standard cache location on disk and its path will be returned.</span>

<span class="sd">        This method returns the transcoded version of the thumbnail originally uploaded to</span>
<span class="sd">        Shotgun. The image returned will always be a fixed-sized jpeg. To retrieve the thumbnail</span>
<span class="sd">        file in its original format and resolution, use :meth:`ShotgunDataRetriever.download_thumbnail_source`</span>
<span class="sd">        instead.</span>

<span class="sd">        This is a helper method meant to make it easy to port over synchronous legacy</span>
<span class="sd">        code - for a better solution, we recommend using the thumbnail retrieval</span>
<span class="sd">        that runs in a background thread.</span>

<span class="sd">        Because Shotgun thumbnail urls have an expiry time, make sure to only</span>
<span class="sd">        pass urls to this method that have been very recently retrieved via a Shotgun find call.</span>

<span class="sd">        :param url: The thumbnail url string that is associated with this thumbnail. This is</span>
<span class="sd">                    the field value as returned by a Shotgun query.</span>
<span class="sd">        :param bundle: App, Framework or Engine object requesting the download.</span>

<span class="sd">        :returns: A path to the thumbnail on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="n">thumb_exists</span> <span class="o">=</span> <span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_get_thumbnail_path</span><span class="p">(</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">bundle</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thumb_exists</span><span class="p">:</span>
            <span class="c1"># create folders on disk</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">ensure_folder_exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">))</span>

            <span class="c1"># download using standard core method. This will ensure that</span>
            <span class="c1"># proxy and connection settings as set in the SG API are used</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Ask sgtk.util.download_url() to append the file type extension</span>
                <span class="c1"># to the input path_to_cached_thumb to get the full path to the</span>
                <span class="c1"># cache file.</span>
                <span class="n">full_path</span> <span class="o">=</span> <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span>
                    <span class="n">bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">path_to_cached_thumb</span> <span class="o">=</span> <span class="n">full_path</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># This may be raised if an older version of core is in use</span>
                <span class="c1"># that doesn&#39;t have the final `use_url_extension` arg implemented</span>
                <span class="c1"># in sgtk.util.download_url() (set to True above). Since the url</span>
                <span class="c1"># is not being checked for an extension, also revert to the</span>
                <span class="c1"># previous behavior of _get_thumbnail_path() which hard-coded a</span>
                <span class="c1"># &quot;.jpeg&quot; extension to the thumbnail file path.</span>
                <span class="n">path_to_cached_thumb</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.jpeg&quot;</span> <span class="o">%</span> <span class="n">path_to_cached_thumb</span>
                <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">path_to_cached_thumb</span><span class="p">)</span>

            <span class="c1"># modify the permissions of the file so it&#39;s writeable by others</span>
            <span class="n">old_umask</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="mo">0o666</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="n">old_umask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Update access and modified time to &quot;now&quot; so the file will be kept</span>
            <span class="c1"># around when culling old files in the cache.</span>
            <span class="c1"># `_get_thumbnail_path` returns a full path with the extension if</span>
            <span class="c1"># the thumb exists.</span>
            <span class="n">_indicate_resource_accessed</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_to_cached_thumb</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.download_thumbnail_source"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.download_thumbnail_source">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">download_thumbnail_source</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">bundle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience and compatibility method for quick and easy synchronous thumbnail download.</span>
<span class="sd">        This will retrieve the source file for a thumbnail given a shotgun entity type and id.</span>
<span class="sd">        If the resolved thumbnail source file has already been cached, a path to it will be</span>
<span class="sd">        returned instantly. Otherwise, it will be downloaded from Shotgun and placed in the</span>
<span class="sd">        standard cache location on disk. The full path to cached thumbnail is returned.</span>

<span class="sd">        This method returns the thumbnail file in the original format and resolution it was</span>
<span class="sd">        uploaded to Shotgun as, which should be considered arbitrary. To retrieve a transcoded</span>
<span class="sd">        fixed-size jpeg version of the thumbnail, use :meth:`ShotgunDataRetriever.download_thumbnail`</span>
<span class="sd">        instead.</span>

<span class="sd">        This is a helper method meant to make it easy to port over synchronous legacy</span>
<span class="sd">        code - for a better solution, we recommend using the thumbnail retrieval</span>
<span class="sd">        that runs in a background thread.</span>

<span class="sd">        :param str entity_type: Shotgun entity type with which the thumb is associated.</span>
<span class="sd">        :param int entity_id: Shotgun entity id with which the thumb is associated.</span>
<span class="sd">        :param bundle: App, Framework or Engine object requesting the download.</span>

<span class="sd">        :returns: A path to the thumbnail on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">thumb_source_url</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlunparse</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span>
                <span class="n">bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">server</span><span class="p">,</span>
                <span class="s2">&quot;/thumbnail/full/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity_type</span><span class="p">)),</span>
                    <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)),</span>
                <span class="p">),</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="n">thumb_exists</span> <span class="o">=</span> <span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_get_thumbnail_path</span><span class="p">(</span>
            <span class="n">thumb_source_url</span><span class="p">,</span> <span class="n">bundle</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thumb_exists</span><span class="p">:</span>
            <span class="c1"># create folders on disk</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">ensure_folder_exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">))</span>

            <span class="c1"># download using standard core method. This will ensure that</span>
            <span class="c1"># proxy and connection settings as set in the SG API are used.</span>
            <span class="c1"># Allow the core method to determine the file type extension</span>
            <span class="c1"># for the url about to be downloaded. Capture the full path to the</span>
            <span class="c1"># thumbnail file as returned by sgtk.util.download_url().</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">full_path</span> <span class="o">=</span> <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span>
                    <span class="n">bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">thumb_source_url</span><span class="p">,</span> <span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">path_to_cached_thumb</span> <span class="o">=</span> <span class="n">full_path</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># This may be raised if an older version of core is in use</span>
                <span class="c1"># that doesn&#39;t have the final `use_url_extension` arg implemented</span>
                <span class="c1"># in sgtk.util.download_url() (set to True above). Since the source</span>
                <span class="c1"># thumbnail url spec does not contain the file type extension, there</span>
                <span class="c1"># is no way to determine the proper file name to download to.</span>
                <span class="c1"># Raise a TankError indicating that a newer version of core must be</span>
                <span class="c1"># used in conjunction with this method.</span>
                <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                    <span class="s2">&quot;Caught error: </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Unable to download source thumbnail URL &#39;</span><span class="si">%s</span><span class="s2">&#39; because the &quot;</span>
                    <span class="s2">&quot;file type extension cannot be determined. Must update to a &quot;</span>
                    <span class="s2">&quot;newer version of core to use ShotgunDataRetriever.&quot;</span>
                    <span class="s2">&quot;download_thumbnail_source().&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">thumb_source_url</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># modify the permissions of the file so it&#39;s writeable by others</span>
            <span class="n">old_umask</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="mo">0o666</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="n">old_umask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Update access and modified time to &quot;now&quot; so the file will be kept</span>
            <span class="c1"># around when culling old files in the cache.</span>
            <span class="c1"># `_get_thumbnail_path` returns a full path with the extension if</span>
            <span class="c1"># the thumb exists.</span>
            <span class="n">_indicate_resource_accessed</span><span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_to_cached_thumb</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.start"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the retriever thread.</span>

<span class="sd">        :raises:    TankError if there is no :class:`~task_manager.BackgroundTaskManager` associated with this instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to start the ShotgunDataRetriever as it has no BackgroundTaskManager!&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">start_processing</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.stop"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gracefully stop the receiver.</span>

<span class="sd">        Once stop() has been called, the object needs to be discarded.</span>
<span class="sd">        This is a blocking call. It will synchronously wait</span>
<span class="sd">        until any potential currently processing item has completed.</span>

<span class="sd">        Note that once stopped the data retriever can&#39;t be restarted as the handle to the</span>
<span class="sd">        :class:`~task_manager.BackgroundTaskManager` instance is released.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_task_manager</span><span class="p">:</span>
            <span class="c1"># we own the task manager so we&#39;ll need to completely shut it down before</span>
            <span class="c1"># returning</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">shut_down</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we don&#39;t own the task manager so just stop any tasks we might be running</span>
            <span class="c1"># and disconnect from it:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">stop_task_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">)</span>

            <span class="c1"># make sure we don&#39;t get exceptions trying to disconnect if the</span>
            <span class="c1"># signals were never connected or somehow disconnected externally.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">task_completed</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_task_completed</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># was never connected</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span>
                    <span class="s2">&quot;Could not disconnect &#39;_on_task_completed&#39; slot from the &quot;</span>
                    <span class="s2">&quot;task manager&#39;s &#39;task_completed&#39; signal: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,)</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">task_failed</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_task_failed</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># was never connected</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
                    <span class="s2">&quot;Could not disconnect &#39;_on_task_failed&#39; slot from the &quot;</span>
                    <span class="s2">&quot;task manager&#39;s &#39;task_failed&#39; signal: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,)</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.clear"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the queue.</span>

<span class="sd">        Any currently processing item will complete without interruption, and signals will be</span>
<span class="sd">        sent out for these items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># stop any tasks running in the task group:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">stop_task_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.stop_work"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.stop_work">[docs]</a>    <span class="k">def</span> <span class="nf">stop_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stop the specified task</span>

<span class="sd">        :param task_id: The task to stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># stop the task:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">stop_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.get_schema"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.get_schema">[docs]</a>    <span class="k">def</span> <span class="nf">get_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the schema_read and schema_entity_read methods asynchronously</span>

<span class="sd">        :param project_id:  If specified, the schema listing returned will</span>
<span class="sd">                            be constrained by the schema settings for</span>
<span class="sd">                            the given project.</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_get_schema</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_DOWNLOAD_SCHEMA_PRIORITY</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;project_id&quot;</span><span class="p">:</span> <span class="n">project_id</span><span class="p">},</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_find"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_find">[docs]</a>    <span class="k">def</span> <span class="nf">execute_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun find query asynchronously.</span>

<span class="sd">        This method takes the same parameters as the Shotgun find() call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``:       args to be passed to the Shotgun find() call</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the Shotgun find() call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_find</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_find_one"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_find_one">[docs]</a>    <span class="k">def</span> <span class="nf">execute_find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun find_one query asynchronously.</span>

<span class="sd">        This method takes the same parameters as the Shotgun find_one() call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``:       args to be passed to the Shotgun find_one() call</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the Shotgun find_one() call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_find_one</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_update"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_update">[docs]</a>    <span class="k">def</span> <span class="nf">execute_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute a Shotgun update call asynchronously</span>

<span class="sd">        This method takes the same parameters as the Shotgun update() call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``:       args to be passed to the Shotgun update() call</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the Shotgun update() call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_update</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_create"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_create">[docs]</a>    <span class="k">def</span> <span class="nf">execute_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute a Shotgun create call asynchronously</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        This method takes the same parameters as the Shotgun create() call.</span>

<span class="sd">        :param ``*args``:       args to be passed to the Shotgun create() call</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the Shotgun create() call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_create</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_delete"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_delete">[docs]</a>    <span class="k">def</span> <span class="nf">execute_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute a Shotgun delete call asynchronously</span>

<span class="sd">        This method takes the same parameters as the Shotgun delete() call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``:       args to be passed to the Shotgun delete() call</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the Shotgun delete() call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_delete</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_method"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_method">[docs]</a>    <span class="k">def</span> <span class="nf">execute_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a generic execution of a method asynchronously.  This is pretty much a</span>
<span class="sd">        wrapper for executing a task through the :class:`~task_manager.BackgroundTaskManager`.</span>

<span class="sd">        The specified method will be called on the following form::</span>

<span class="sd">            method(sg, data)</span>

<span class="sd">        Where sg is a shotgun API instance. Data is typically</span>
<span class="sd">        a dictionary with specific data that the method needs.</span>
<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param method:      The method that should be executed.</span>
<span class="sd">        :param ``*args``:       args to be passed to the method</span>
<span class="sd">        :param ``**kwargs``:    Named parameters to be passed to the method</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># note that as the &#39;task&#39; is actually going to call through to another method, we</span>
        <span class="c1"># encode the method name, args and kwargs in the task&#39;s kwargs dictionary as this</span>
        <span class="c1"># keeps them nicely encapsulated.</span>
        <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;method_args&quot;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span> <span class="s2">&quot;method_kwargs&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_method</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">task_kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_text_search"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_text_search">[docs]</a>    <span class="k">def</span> <span class="nf">execute_text_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun ``text_search`` query asynchronously.</span>

<span class="sd">        See the python api documentation here:</span>
<span class="sd">            https://github.com/shotgunsoftware/python-api/wiki</span>

<span class="sd">        This method takes the same parameters as the Shotgun ``text_search()`` call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``: args to be passed to the Shotgun ``text_search()`` call</span>
<span class="sd">        :param ``**kwargs``: Named parameters to be passed to the Shotgun ``text_search()`` call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_text_search</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_nav_expand"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_nav_expand">[docs]</a>    <span class="k">def</span> <span class="nf">execute_nav_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun ``nav_expand`` query asynchronously.</span>

<span class="sd">        See the python api documentation here:</span>
<span class="sd">            https://github.com/shotgunsoftware/python-api/wiki</span>

<span class="sd">        This method takes the same parameters as the Shotgun ``nav_expand()`` call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``: args to be passed to the Shotgun ``nav_expand()`` call</span>
<span class="sd">        :param ``**kwargs``: Named parameters to be passed to the Shotgun ``nav_expand()`` call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_nav_expand</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_nav_search_string"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_nav_search_string">[docs]</a>    <span class="k">def</span> <span class="nf">execute_nav_search_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun ``nav_search_string`` query asynchronously.</span>

<span class="sd">        See the python api documentation here:</span>
<span class="sd">            https://github.com/shotgunsoftware/python-api/wiki</span>

<span class="sd">        This method takes the same parameters as the Shotgun ``nav_search_string()`` call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``: args to be passed to the Shotgun ``nav_search_string()`` call</span>
<span class="sd">        :param ``**kwargs``: Named parameters to be passed to the Shotgun ``nav_search_string()`` call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_nav_search_string</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.execute_nav_search_entity"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.execute_nav_search_entity">[docs]</a>    <span class="k">def</span> <span class="nf">execute_nav_search_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a Shotgun ``nav_search_entity`` query asynchronously.</span>

<span class="sd">        See the python api documentation here:</span>
<span class="sd">            https://github.com/shotgunsoftware/python-api/wiki</span>

<span class="sd">        This method takes the same parameters as the Shotgun ``nav_search_entity()`` call.</span>

<span class="sd">        The query will be queued up and once processed, either a</span>
<span class="sd">        work_completed or work_failure signal will be emitted.</span>

<span class="sd">        :param ``*args``: args to be passed to the Shotgun ``nav_search_entity()`` call</span>
<span class="sd">        :param ``**kwargs``: Named parameters to be passed to the Shotgun ``nav_search_entity()`` call</span>
<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_execute_nav_search_entity</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_SG_CALL_PRIORITY</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_add_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_cb</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">task_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">task_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplified wrapper to add a task to the task manager.  All tasks get added into</span>
<span class="sd">        the same group (self._bg_tasks_group) and the returned task_id is cast to a string</span>
<span class="sd">        to retain backwards compatibility (it used to return a uuid string).</span>

<span class="sd">        :param task_cb:     The function to execute for the task</span>
<span class="sd">        :param priority:    The priority the task should be run with</span>
<span class="sd">        :param task_args:   Arguments that should be passed to the task callback</span>
<span class="sd">        :param task_kwargs: Named arguments that should be passed to the task callback</span>
<span class="sd">        :returns:           String representation of the task id</span>
<span class="sd">        :raises:            TankError if there is no task manager available to add the task to!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                <span class="s2">&quot;Data retriever does not have a task manager to add the task to!&quot;</span>
            <span class="p">)</span>

        <span class="n">task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span>
            <span class="n">task_cb</span><span class="p">,</span>
            <span class="n">priority</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">,</span>
            <span class="n">task_args</span><span class="o">=</span><span class="n">task_args</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="n">task_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>

<div class="viewcode-block" id="ShotgunDataRetriever.request_attachment"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.request_attachment">[docs]</a>    <span class="k">def</span> <span class="nf">request_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attachment_entity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downloads an attachment from Shotgun asynchronously or returns a cached</span>
<span class="sd">        file path if found.</span>

<span class="sd">        .. note:: The provided Attachment entity definition must contain, at a</span>
<span class="sd">                  minimum, the &quot;this_file&quot; substructure.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">                &quot;id&quot;: 597,</span>
<span class="sd">                &quot;this_file&quot;: {</span>
<span class="sd">                    &quot;content_type&quot;: &quot;image/png&quot;,</span>
<span class="sd">                    &quot;id&quot;: 597,</span>
<span class="sd">                    &quot;link_type&quot;: &quot;upload&quot;,</span>
<span class="sd">                    &quot;name&quot;: &quot;test.png&quot;,</span>
<span class="sd">                    &quot;type&quot;: &quot;Attachment&quot;,</span>
<span class="sd">                    &quot;url&quot;: &quot;https://abc.shotgunstudio.com/file_serve/attachment/597&quot;</span>
<span class="sd">                },</span>
<span class="sd">                &quot;type&quot;: &quot;Attachment&quot;</span>
<span class="sd">            }</span>

<span class="sd">        :param dict attachment_entity: The Attachment entity to download data from.</span>

<span class="sd">        :returns: A unique identifier representing this request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span>
                <span class="s2">&quot;No task manager has been associated with this data retriever. &quot;</span>
                <span class="s2">&quot;Unable to request attachment.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># always add check for attachments already downloaded:</span>
        <span class="n">check_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_check_attachment</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHECK_ATTACHMENT_PRIORITY</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">attachment_entity</span><span class="o">=</span><span class="n">attachment_entity</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Add download thumbnail task.  This is dependent on the check task above and will be passed</span>
        <span class="c1"># the returned results from that task in addition to the kwargs specified below.  This allows</span>
        <span class="c1"># a task dependency chain to be created with different priorities for the separate tasks.</span>
        <span class="n">dl_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_download_attachment</span><span class="p">,</span>
            <span class="n">upstream_task_ids</span><span class="o">=</span><span class="p">[</span><span class="n">check_task_id</span><span class="p">],</span>
            <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_DOWNLOAD_ATTACHMENT_PRIORITY</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">attachment_entity</span><span class="o">=</span><span class="n">attachment_entity</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># all results for requesting a thumbnail should be returned with the same id so use</span>
        <span class="c1"># a mapping to track the &#39;primary&#39; task id:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="p">[</span><span class="n">dl_task_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_task_id</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">check_task_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.request_thumbnail"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.request_thumbnail">[docs]</a>    <span class="k">def</span> <span class="nf">request_thumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">load_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downloads a thumbnail from Shotgun asynchronously or returns a cached thumbnail</span>
<span class="sd">        if found.  Optionally loads the thumbnail into a QImage.</span>

<span class="sd">        :param url:         The thumbnail url string that is associated with this thumbnail. This is</span>
<span class="sd">                            the field value as returned by a Shotgun query.</span>
<span class="sd">        :param entity_type: Shotgun entity type with which the thumb is associated.</span>
<span class="sd">        :param entity_id:   Shotgun entity id with which the thumb is associated.</span>
<span class="sd">        :param field:       Thumbnail field. Normally &#39;image&#39; but could also for example be a deep</span>
<span class="sd">                            link field such as ``sg_sequence.Sequence.image``</span>
<span class="sd">        :param load_image:  If set to True, the return data structure will contain a QImage object</span>
<span class="sd">                            with the image data loaded.</span>

<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span>
                <span class="s2">&quot;No task manager has been associated with this data retriever. &quot;</span>
                <span class="s2">&quot;Unable to request thumbnail.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># always add check for thumbnail already downloaded:</span>
        <span class="n">check_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_check_thumbnail</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHECK_THUMB_PRIORITY</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="s2">&quot;load_image&quot;</span><span class="p">:</span> <span class="n">load_image</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># Add download thumbnail task.  This is dependent on the check task above and will be passed</span>
        <span class="c1"># the returned results from that task in addition to the kwargs specified below.  This allows</span>
        <span class="c1"># a task dependency chain to be created with different priorities for the separate tasks.</span>
        <span class="n">dl_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task_manager</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task_download_thumbnail</span><span class="p">,</span>
            <span class="n">upstream_task_ids</span><span class="o">=</span><span class="p">[</span><span class="n">check_task_id</span><span class="p">],</span>
            <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_DOWNLOAD_THUMB_PRIORITY</span><span class="p">,</span>
            <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">,</span>
            <span class="n">task_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
                <span class="s2">&quot;entity_type&quot;</span><span class="p">:</span> <span class="n">entity_type</span><span class="p">,</span>
                <span class="s2">&quot;entity_id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">,</span>
                <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span>
                <span class="s2">&quot;load_image&quot;</span><span class="p">:</span> <span class="n">load_image</span>
                <span class="c1"># &quot;thumb_path&quot;:&lt;passed from check task&gt;</span>
                <span class="c1"># &quot;image&quot;:&lt;passed from check task&gt;</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># all results for requesting a thumbnail should be returned with the same id so use</span>
        <span class="c1"># a mapping to track the &#39;primary&#39; task id:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="p">[</span><span class="n">dl_task_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_task_id</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">check_task_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShotgunDataRetriever.request_thumbnail_source"><a class="viewcode-back" href="../../shotgun_data.html#shotgun_data.ShotgunDataRetriever.request_thumbnail_source">[docs]</a>    <span class="k">def</span> <span class="nf">request_thumbnail_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">load_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downloads a thumbnail from Shotgun asynchronously or returns a cached thumbnail</span>
<span class="sd">        if found.  Optionally loads the thumbnail into a QImage.</span>

<span class="sd">        :param entity_type: Shotgun entity type with which the thumb is associated.</span>
<span class="sd">        :param entity_id:   Shotgun entity id with which the thumb is associated.</span>
<span class="sd">        :param load_image:  If set to True, the return data structure will contain a</span>
<span class="sd">                            QImage object with the image data loaded.</span>

<span class="sd">        :returns: A unique identifier representing this request. This</span>
<span class="sd">                  identifier is also part of the payload sent via the</span>
<span class="sd">                  work_completed and work_failure signals, making it</span>
<span class="sd">                  possible to match them up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct the url that refers to the thumbnail&#39;s source image</span>
        <span class="n">thumb_source_url</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlunparse</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">server</span><span class="p">,</span>
                <span class="s2">&quot;/thumbnail/full/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity_type</span><span class="p">)),</span>
                    <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)),</span>
                <span class="p">),</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_thumbnail</span><span class="p">(</span>
            <span class="n">thumb_source_url</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">load_image</span>
        <span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------------------------------------------</span>
    <span class="c1"># Background task management and methods</span>

    <span class="k">def</span> <span class="nf">_download_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downloads a file located at the given url to the provided file path.</span>

<span class="sd">        :param str file_path: The target path.</span>
<span class="sd">        :param str url: The url location of the file to download.</span>
<span class="sd">        :param str entity_type: The Shotgun entity type that the url is</span>
<span class="sd">                                associated with. In the event that the</span>
<span class="sd">                                provided url has expired, the entity</span>
<span class="sd">                                type and id provided will be used to query</span>
<span class="sd">                                a fresh url.</span>
<span class="sd">        :param int entity_id: The Shotgun entity id that the url is</span>
<span class="sd">                              associated with. In the event that the</span>
<span class="sd">                              provided url has expired, the entity type and</span>
<span class="sd">                              id provided will be used to query a fresh url.</span>
<span class="sd">        :param str field: The name of the field that contains the url. If</span>
<span class="sd">                          the url needs to be requeried, this field will be</span>
<span class="sd">                          where the fresh url is pulled from.</span>
<span class="sd">        :returns: Full path the downloaded file. This value may be different</span>
<span class="sd">                  than the input `file_path` if the resolved url&#39;s extension</span>
<span class="sd">                  differed from what was specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># download using standard core method. This will ensure that</span>
            <span class="c1"># proxy and connection settings as set in the SG API are used</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Ask sgtk.util.download_url() to append the file type extension</span>
                <span class="c1"># to the input file_path to get the full path to the cache file.</span>
                <span class="n">download_path</span> <span class="o">=</span> <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">file_path</span> <span class="o">=</span> <span class="n">download_path</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># This may be raised if an older version of core is in use</span>
                <span class="c1"># that doesn&#39;t have the final `use_url_extension` arg implemented</span>
                <span class="c1"># in sgtk.util.download_url() (set to True above). Since the url</span>
                <span class="c1"># is not being checked for an extension, also revert to the</span>
                <span class="c1"># previous behavior of _get_thumbnail_path() which hard-coded a</span>
                <span class="c1"># &quot;.jpeg&quot; extension to the thumbnail file path.</span>
                <span class="n">file_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.jpeg&quot;</span> <span class="o">%</span> <span class="n">file_path</span>
                <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">TankError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
                    <span class="n">entity_type</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">]],</span> <span class="p">[</span><span class="n">field</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">sg_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sg_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># This means there&#39;s nothing in Shotgun for this field, which</span>
                    <span class="c1"># means we can&#39;t download anything.</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                        <span class="s2">&quot;Field </span><span class="si">%s</span><span class="s2"> does not contain data for </span><span class="si">%s</span><span class="s2"> (id=</span><span class="si">%s</span><span class="s2">).&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Again, download using standard core method. This will ensure that</span>
                    <span class="c1"># proxy and connection settings as set in the SG API are used.</span>
                    <span class="n">url</span> <span class="o">=</span> <span class="n">sg_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Ask sgtk.util.download_url() to append the file type extension</span>
                        <span class="c1"># to the input file_path to get the full path to the cache file.</span>
                        <span class="n">download_path</span> <span class="o">=</span> <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="n">file_path</span> <span class="o">=</span> <span class="n">download_path</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="c1"># This may be raised if an older version of core is in use</span>
                        <span class="c1"># that doesn&#39;t have the final `use_url_extension` arg implemented</span>
                        <span class="c1"># in sgtk.util.download_url() (set to True above). Since the url</span>
                        <span class="c1"># is not being checked for an extension, also revert to the</span>
                        <span class="c1"># previous behavior of _get_thumbnail_path() which hard-coded a</span>
                        <span class="c1"># &quot;.jpeg&quot; extension to the thumbnail file path.</span>
                        <span class="n">file_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.jpeg&quot;</span> <span class="o">%</span> <span class="n">file_path</span>
                        <span class="n">sgtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">download_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="c1"># now we have a thumbnail on disk, either via the direct download, or via the</span>
        <span class="c1"># url-fresh-then-download approach.  Because the file is downloaded with user-only</span>
        <span class="c1"># permissions we have to modify the permissions so that it&#39;s writeable by others</span>
        <span class="n">old_umask</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="mo">0o666</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="n">old_umask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">file_path</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_attachment_path</span><span class="p">(</span><span class="n">attachment_entity</span><span class="p">,</span> <span class="n">bundle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the location on disk suitable for an attachment file.</span>

<span class="sd">        :param dict attachment_entity: The Attachment entity definition.</span>
<span class="sd">        :param bundle: App, Engine or Framework instance</span>

<span class="sd">        :returns: Path as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">attachment_entity</span><span class="p">[</span><span class="s2">&quot;this_file&quot;</span><span class="p">][</span><span class="s2">&quot;url&quot;</span><span class="p">]</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">attachment_entity</span><span class="p">[</span><span class="s2">&quot;this_file&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

        <span class="n">directory_path</span><span class="p">,</span> <span class="n">path_exists</span> <span class="o">=</span> <span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_get_thumbnail_path</span><span class="p">(</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">directory_only</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_thumbnail_path</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">directory_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the location on disk suitable for a thumbnail given its url and</span>
<span class="sd">        whether a cached file for the specified ``url`` already exists. Two cases</span>
<span class="sd">        are handled:</span>

<span class="sd">        Case A: ``directory_only`` is set to False and the ``url`` cache file does not exist:</span>

<span class="sd">            &gt;&gt;&gt; (path, cache_exists) = _get_thumbnail_path(&quot;https://foo/bar/baz.jpg&quot;)</span>

<span class="sd">            Where return data ``(path, cache_exists) = (&#39;/tmp/xx/yy/1245/6678&#39;, False)``</span>

<span class="sd">            This will always return a file path without an extension. Since the cache</span>
<span class="sd">            file does not exist, download it using sgtk.util.download_url(), setting</span>
<span class="sd">            the ``use_url_extension`` arg to True, which will return the full path to the</span>
<span class="sd">            cached file:</span>

<span class="sd">            &gt;&gt;&gt; full_path = sgtk.util.download_url(sg, &quot;https://foo/bar/baz.jpg&quot;, path, True)</span>

<span class="sd">            Where ``full_path`` now contains a file extension: /tmp/xx/yy/1245/6678.jpg</span>

<span class="sd">        Case B: ``directory_only`` is set to False and the ``url`` cache file does exist:</span>

<span class="sd">            &gt;&gt;&gt; (path, cache_exists) = _get_thumbnail_path(&quot;https://foo/bar/baz.jpg&quot;)</span>

<span class="sd">            Where return data ``(path, cache_exists) = (&#39;/tmp/xx/yy/1245/6678.jpg&#39;, True)``</span>

<span class="sd">            This will always return the full path to the cached file, so no need to</span>
<span class="sd">            do any addtional work.</span>


<span class="sd">        :param str url: Path to a thumbnail</span>
<span class="sd">        :param bundle: App, Engine or Framework instance</span>
<span class="sd">        :param bool directory_only: Whether to return a directory path or a</span>
<span class="sd">                                    full file path. Default is False, which</span>
<span class="sd">                                    indicates a full file path, including</span>
<span class="sd">                                    file name, will be returned.</span>

<span class="sd">        :returns: Tuple (str, bool) Path or path with basename as a string,</span>
<span class="sd">                                    cached thumbnail exists on disk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we don&#39;t have a URL, then we know we don&#39;t</span>
        <span class="c1"># have a thumbnail to worry about.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># hash the path portion of the thumbnail url</span>
        <span class="n">url_obj</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">url_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
        <span class="n">url_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">ensure_binary</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">url_obj</span><span class="o">.</span><span class="n">path</span><span class="p">)))</span>
        <span class="n">hash_str</span> <span class="o">=</span> <span class="n">url_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

        <span class="c1"># Now turn this hash into a tree structure. For a discussion about sensible</span>
        <span class="c1"># sharding methodology, see</span>
        <span class="c1"># http://stackoverflow.com/questions/13841931/using-guids-as-folder-names-splitting-up</span>
        <span class="c1">#</span>
        <span class="c1"># From the hash, generate paths on the form C1C2/C3C4/rest_of_hash</span>
        <span class="c1"># (where C1 is the first character of the hash). For a million evenly distributed</span>
        <span class="c1"># items, this means ~15 items per folder.</span>
        <span class="n">first_folder</span> <span class="o">=</span> <span class="n">hash_str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">second_folder</span> <span class="o">=</span> <span class="n">hash_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Establish the cache path directory</span>
        <span class="c1"># If possible we share thumbnails at the site cache level.</span>
        <span class="c1"># Site cache location was introduced in tk-core &gt; v0.18.118, to not</span>
        <span class="c1"># introduce a dependency on a tk-core release, we simply check if the method</span>
        <span class="c1"># is available or not.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="s2">&quot;site_cache_location&quot;</span><span class="p">):</span>
            <span class="n">cache_path_items</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bundle</span><span class="o">.</span><span class="n">site_cache_location</span><span class="p">,</span>
                <span class="s2">&quot;thumbs&quot;</span><span class="p">,</span>
                <span class="n">first_folder</span><span class="p">,</span>
                <span class="n">second_folder</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to caching per project/pipeline config/plugin id.</span>
            <span class="n">cache_path_items</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bundle</span><span class="o">.</span><span class="n">cache_location</span><span class="p">,</span>
                <span class="s2">&quot;thumbs&quot;</span><span class="p">,</span>
                <span class="n">first_folder</span><span class="p">,</span>
                <span class="n">second_folder</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="n">cached_thumb_exists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># If we were only asked to give back a directory path then we can</span>
        <span class="c1"># skip building and appending a file name.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directory_only</span><span class="p">:</span>
            <span class="c1"># Look for an existing cache file. Use the glob module since</span>
            <span class="c1"># we do not know what the file type of the cache file is.</span>
            <span class="n">path_base</span> <span class="o">=</span> <span class="n">hash_str</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
            <span class="n">cache_base</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">cache_path_items</span> <span class="o">+</span> <span class="p">[</span><span class="n">path_base</span><span class="p">]))</span>

            <span class="c1"># Attempt to match something that looks like:</span>
            <span class="c1">#   /bundle_cache_location/thumbs/C1C2/C3C4/rest_of_hash.*</span>
            <span class="n">cache_matches</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.*&quot;</span> <span class="o">%</span> <span class="n">cache_base</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache_matches</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache_matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If somehow more than one cache file exists, the wrong icon may be displayed.</span>
                    <span class="c1"># Log some information about how to resolve this problem.</span>
                    <span class="n">bundle</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
                        <span class="s2">&quot;More than one cached file found for url &#39;</span><span class="si">%s</span><span class="s2">&#39;:&quot;</span> <span class="o">%</span> <span class="n">url</span>
                    <span class="p">)</span>
                    <span class="p">[</span>
                        <span class="n">bundle</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;    </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cache_match</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cache_match</span> <span class="ow">in</span> <span class="n">cache_matches</span>
                    <span class="p">]</span>
                    <span class="n">bundle</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
                        <span class="s2">&quot;Using &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                        <span class="s2">&quot;If this is incorrect, manually remove the undesired cache file.&quot;</span>
                        <span class="o">%</span> <span class="n">cache_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="c1"># Cache file exists, so append the full file name (e.g. rest_of_hash.png)</span>
                <span class="n">cache_path_items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">cache_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">cached_thumb_exists</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Cache file does not exist, so only append the basename of the cached</span>
                <span class="c1"># thumbnail that does NOT include the file type extension (e.g. rest_of_hash).</span>
                <span class="c1"># The extension will be appended later by a call to sgtk.util.download_url()</span>
                <span class="n">cache_path_items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_base</span><span class="p">)</span>

        <span class="c1"># Join up the path cache items which result in either a directory like</span>
        <span class="c1"># &#39;/bundle_cache_location/thumbs/C1C2/C3C4&#39; or a file path like</span>
        <span class="c1"># &#39;/bundle_cache_location/thumbs/C1C2/C3C4/rest_of_hash&#39; if the cache file</span>
        <span class="c1"># does not exist or &#39;/bundle_cache_location/thumbs/C1C2/C3C4/rest_of_hash.ext&#39;</span>
        <span class="c1"># if it does.</span>
        <span class="n">path_to_cached_thumb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">cache_path_items</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">path_to_cached_thumb</span><span class="p">,</span> <span class="n">cached_thumb_exists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_task_get_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to retrieve the fields</span>
<span class="sd">        and types schema from Shotgun</span>

<span class="sd">        :param project_id:  The id of the project to query the schema for or None to</span>
<span class="sd">                            retrieve for all projects</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with the schema</span>
<span class="sd">                            fields and types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">project_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">project_id</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># read in details about all fields</span>
        <span class="n">sg_field_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">schema_read</span><span class="p">(</span><span class="n">project</span><span class="p">)</span>

        <span class="c1"># and read in details about all entity types</span>
        <span class="n">sg_type_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">schema_entity_read</span><span class="p">(</span><span class="n">project</span><span class="p">)</span>

        <span class="c1"># need to wrap it in a dict not to confuse pyqt&#39;s signals and type system</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;schema&quot;</span><span class="p">,</span> <span class="s2">&quot;fields&quot;</span><span class="p">:</span> <span class="n">sg_field_schema</span><span class="p">,</span> <span class="s2">&quot;types&quot;</span><span class="p">:</span> <span class="n">sg_type_schema</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        find query</span>

<span class="sd">        :param ``*args``:       Unnamed arguments to be passed to the find() call</span>
<span class="sd">        :param ``**kwargs``:    Named arguments to be passed to the find() call</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">                            returned by the find() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;find&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        find_one query</span>

<span class="sd">        :param ``*args``:       Unnamed arguments to be passed to the find_one() call</span>
<span class="sd">        :param ``**kwargs``:    Named arguments to be passed to the find_one() call</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">                            returned by the find_one() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;find_one&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        update call</span>

<span class="sd">        :param ``*args``:       Unnamed arguments to be passed to the update() call</span>
<span class="sd">        :param ``**kwargs``:    Named arguments to be passed to the update() call</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">                            returned by the update() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;update&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        create call</span>

<span class="sd">        :param ``*args``:       Unnamed arguments to be passed to the create() call</span>
<span class="sd">        :param ``**kwargs``:    Named arguments to be passed to the create() call</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">                            returned by the create() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;create&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        delete call</span>

<span class="sd">        :param ``*args``:       Unnamed arguments to be passed to the delete() call</span>
<span class="sd">        :param ``**kwargs``:    Named arguments to be passed to the delete() call</span>
<span class="sd">        :returns:           Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">                            returned by the delete() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_args</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to execute a method</span>
<span class="sd">        with a thread-specific shotgun connection.</span>

<span class="sd">        :param method:          The method to be run asynchronously</span>
<span class="sd">        :param method_args:     Arguments to be passed to the method</span>
<span class="sd">        :param method_kwargs:   Named arguments to be passed to the method</span>
<span class="sd">        :returns:               Dictionary containing the &#39;action&#39; together with the result</span>
<span class="sd">                                returned by the method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="p">,</span> <span class="o">*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">**</span><span class="n">method_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="s2">&quot;result&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_text_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        ``text_search`` query</span>

<span class="sd">        :param ``*args``: Unnamed arguments to be passed to the ``text_search()`` call</span>
<span class="sd">        :param ``**kwargs``: Named arguments to be passed to the ``text_search()`` call</span>
<span class="sd">        :returns: Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">            returned by the find() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">text_search</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;text_search&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_nav_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        ``nav_expand`` query</span>

<span class="sd">        :param ``*args``: Unnamed arguments to be passed to the ``nav_expand()`` call</span>
<span class="sd">        :param ``**kwargs``: Named arguments to be passed to the ``nav_expand()`` call</span>
<span class="sd">        :returns: Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">            returned by the find() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">nav_expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;nav_expand&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_nav_search_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        ``nav_search_string`` query</span>

<span class="sd">        :param ``*args``: Unnamed arguments to be passed to the ``nav_search_string()`` call</span>
<span class="sd">        :param ``**kwargs``: Named arguments to be passed to the ``nav_search_string()`` call</span>
<span class="sd">        :returns: Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">            returned by the find() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">nav_search_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># running an older core which doesn&#39;t come with a</span>
            <span class="c1"># sg API which has a nav_search_string() method</span>
            <span class="n">sg_res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;nav_search_string&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_execute_nav_search_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that gets executed in a background task/thread to perform a Shotgun</span>
<span class="sd">        ``nav_search_entity`` query</span>

<span class="sd">        :param ``*args``: Unnamed arguments to be passed to the ``nav_search_entity()`` call</span>
<span class="sd">        :param ``**kwargs``: Named arguments to be passed to the ``nav_search_entity()`` call</span>
<span class="sd">        :returns: Dictionary containing the &#39;action&#39; together with result</span>
<span class="sd">            returned by the find() call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Project can&#39;t be resolved with the API right now due to a bug on the Shotgun-side.</span>
        <span class="c1"># Mock the call instead.</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="n">project_id</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="n">sg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
                <span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">project_id</span><span class="p">]],</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">sg_res</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;incremental_path&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;/Project/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">project_id</span><span class="p">],</span>
                    <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">sg_data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;path_label&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;project_id&quot;</span><span class="p">:</span> <span class="n">project_id</span><span class="p">,</span>
                    <span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">sg_data</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sg_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">nav_search_entity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># running an older core which doesn&#39;t come with a</span>
                <span class="c1"># sg API which has a nav_search_string() method</span>
                <span class="n">sg_res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;nav_search_entity&quot;</span><span class="p">,</span> <span class="s2">&quot;sg_result&quot;</span><span class="p">:</span> <span class="n">sg_res</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_check_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attachment_entity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check to see if an attachment file exists for the specified Attachment</span>
<span class="sd">        entity.</span>

<span class="sd">        :param dict attachment_entity: The Attachment entity definition.</span>

<span class="sd">        :returns: A dictionary containing the cached path for the specified</span>
<span class="sd">                  Attachment entity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">attachment_entity</span><span class="p">[</span><span class="s2">&quot;this_file&quot;</span><span class="p">][</span><span class="s2">&quot;url&quot;</span><span class="p">]</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">attachment_entity</span><span class="p">[</span><span class="s2">&quot;this_file&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;check_attachment&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attachment_path</span><span class="p">(</span><span class="n">attachment_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_path</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="c1"># Update access and modified time to &quot;now&quot; so the file will be kept</span>
            <span class="c1"># around when culling old files in the cache.</span>
            <span class="n">_indicate_resource_accessed</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;file_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_path</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_task_check_thumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">load_image</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check to see if a thumbnail exists for the specified url.  If it does then it is returned.</span>

<span class="sd">        :param url:         The url to return the cached path for</span>
<span class="sd">        :param load_image:  If True then if the thumbnail is found in the cache then the file will</span>
<span class="sd">                            be loaded into a QImage</span>
<span class="sd">        :returns:           A dictionary containing the cached path for the specified url and a QImage</span>
<span class="sd">                            if load_image is True and the thumbnail exists in the cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If there&#39;s no URL then we definitely won&#39;t be finding</span>
        <span class="c1"># a thumbnail.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;check_thumbnail&quot;</span><span class="p">,</span> <span class="s2">&quot;thumb_path&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># first look up the path in the cache:</span>
        <span class="n">thumb_path</span><span class="p">,</span> <span class="n">thumb_exists</span> <span class="o">=</span> <span class="n">ShotgunDataRetriever</span><span class="o">.</span><span class="n">_get_thumbnail_path</span><span class="p">(</span>
            <span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span>
        <span class="p">)</span>
        <span class="n">thumb_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">thumb_exists</span><span class="p">:</span>
            <span class="c1"># Update access and modified time to &quot;now&quot; so the file will be kept</span>
            <span class="c1"># around when culling old files in the cache.</span>
            <span class="n">_indicate_resource_accessed</span><span class="p">(</span><span class="n">thumb_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">load_image</span><span class="p">:</span>
                <span class="c1"># load the thumbnail into a QImage:</span>
                <span class="n">thumb_image</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QImage</span><span class="p">()</span>
                <span class="n">thumb_image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">thumb_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thumb_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;check_thumbnail&quot;</span><span class="p">,</span>
            <span class="s2">&quot;thumb_path&quot;</span><span class="p">:</span> <span class="n">thumb_path</span><span class="p">,</span>
            <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">thumb_image</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_task_download_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">attachment_entity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Download the specified attachment. This downloads the file associated with</span>
<span class="sd">        the provided Attachment entity into the framework&#39;s cache directory structure</span>
<span class="sd">        and returns the cached path.</span>

<span class="sd">        :param str file_path: The target file path to download to.</span>
<span class="sd">        :param dict attachment_entity: The Attachment entity definition.</span>

<span class="sd">        :returns: A dictionary containing the cached path for the specified</span>
<span class="sd">                  Attachment entity, as well as an action identifier that</span>
<span class="sd">                  marks the data as having come from a &quot;download_attachment&quot;</span>
<span class="sd">                  task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attachment_path</span><span class="p">(</span><span class="n">attachment_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">ensure_folder_exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>

        <span class="c1"># Even if `_task_check_attachment` didn&#39;t see the target file, we check</span>
        <span class="c1"># again if it exists as the attachment might have been downloaded in the</span>
        <span class="c1"># mean time. We don&#39;t update the modification time on the file to prevent</span>
        <span class="c1"># it to be culled in cache cleanup, as it has been freshly downloaded.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">download_attachment</span><span class="p">(</span>
                <span class="n">attachment</span><span class="o">=</span><span class="n">attachment_entity</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="n">file_path</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;download_attachment&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="n">file_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_task_download_thumbnail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">thumb_path</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">load_image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Download the thumbnail for the specified entity type, id and field.  This downloads the</span>
<span class="sd">        thumbnail into the thumbnail cache directory and returns the cached path.</span>

<span class="sd">        If thumb_path already contains a path then this method does nothing and just returns the path</span>
<span class="sd">        without further checking/work.</span>

<span class="sd">        :param thumb_path:  Path to an existing thumbnail or None.</span>
<span class="sd">        :param url:         The url for the thumbnail which may or may not still be valid!</span>
<span class="sd">        :param entity_type: Type of the entity to retrieve the thumbnail for</span>
<span class="sd">        :param entity_id:   Id of the entity to retrieve the thumbnail for</span>
<span class="sd">        :param field:       The field on the entity that holds the url for the thumbnail to retrieve</span>
<span class="sd">        :param load_image:  If True then if the thumbnail is downloaded from Shotgun then the file will</span>
<span class="sd">                            be loaded into a QImage</span>
<span class="sd">        :returns:           A dictionary containing the cached path for the specified url and a QImage</span>
<span class="sd">                            if load_image is True and the thumbnail exists in the cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">thumb_path</span><span class="p">:</span>
            <span class="c1"># no need to do anything as the thumbnail was previously</span>
            <span class="c1"># found when we ran the check!</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># download the actual thumbnail. Because of S3, the url</span>
        <span class="c1"># may have expired - in that case fall back, get a fresh url</span>
        <span class="c1"># from shotgun and try again</span>
        <span class="n">thumb_path</span><span class="p">,</span> <span class="n">thumb_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_thumbnail_path</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="p">)</span>

        <span class="c1"># If we have no path, then there&#39;s no thumbnail that exists.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thumb_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># There may be a case where another process has alrady downloaded the thumbnail for us, so</span>
        <span class="c1"># make sure that we aren&#39;t doing any extra work :)</span>
        <span class="c1"># If it is the case, we don&#39;t have to update the file modification time</span>
        <span class="c1"># to prevent it to be culled in cache clean up: it has been freshly</span>
        <span class="c1"># downloaded as our `_task_check_thumbnail` task didn&#39;t see it.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thumb_exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle</span><span class="o">.</span><span class="n">ensure_folder_exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">thumb_path</span><span class="p">))</span>

            <span class="c1"># try to download based on the path we have</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">thumb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_download_url</span><span class="p">(</span>
                    <span class="n">thumb_path</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">field</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">thumb_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># finally, see if we should also load in the image</span>
        <span class="n">thumb_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">thumb_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">load_image</span><span class="p">:</span>
                <span class="c1"># load the thumbnail into a QImage:</span>
                <span class="n">thumb_image</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QImage</span><span class="p">()</span>
                <span class="n">thumb_image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">thumb_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thumb_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">action</span><span class="o">=</span><span class="s2">&quot;download_thumbnail&quot;</span><span class="p">,</span> <span class="n">thumb_path</span><span class="o">=</span><span class="n">thumb_path</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">thumb_image</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_task_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slot triggered when a task is completed.</span>

<span class="sd">        :param task_id: The id of the task that has completed</span>
<span class="sd">        :param group:   The group the task belongs to</span>
<span class="sd">        :param result:  The task result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">:</span>
            <span class="c1"># ignore - it isn&#39;t our task! - this slot will recieve signals for tasks started</span>
            <span class="c1"># by other objects/instances so we need to make sure we filter them out here</span>
            <span class="k">return</span>

        <span class="n">action</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;action&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;find&quot;</span><span class="p">,</span>
            <span class="s2">&quot;find_one&quot;</span><span class="p">,</span>
            <span class="s2">&quot;create&quot;</span><span class="p">,</span>
            <span class="s2">&quot;delete&quot;</span><span class="p">,</span>
            <span class="s2">&quot;update&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nav_expand&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nav_search_string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;text_search&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span> <span class="n">action</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;sg&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;sg_result&quot;</span><span class="p">]})</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;schema&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span>
                <span class="s2">&quot;schema&quot;</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;fields&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">],</span> <span class="s2">&quot;types&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;types&quot;</span><span class="p">]},</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;return_value&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">]}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;check_thumbnail&quot;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;thumb_path&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                <span class="c1"># check found a thumbnail!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span>
                    <span class="s2">&quot;check_thumbnail&quot;</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;thumb_path&quot;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]},</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;download_thumbnail&quot;</span><span class="p">:</span>
            <span class="c1"># look up the primary thumbnail task id in the map:</span>
            <span class="n">thumb_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thumb_task_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">thumb_task_id</span><span class="p">),</span>
                    <span class="s2">&quot;download_thumbnail&quot;</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;thumb_path&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;thumb_path&quot;</span><span class="p">],</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]},</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;check_attachment&quot;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;file_path&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span> <span class="s2">&quot;check_attachment&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;file_path&quot;</span><span class="p">:</span> <span class="n">path</span><span class="p">}</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;download_attachment&quot;</span><span class="p">:</span>
            <span class="n">attachment_task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attachment_task_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_completed</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">attachment_task_id</span><span class="p">),</span>
                    <span class="s2">&quot;download_attachment&quot;</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;file_path&quot;</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;file_path&quot;</span><span class="p">]},</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_task_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slot triggered when a task fails for some reason</span>

<span class="sd">        :param task_id: The id of the task that failed</span>
<span class="sd">        :param msg:     The error/exception message for the failed task</span>
<span class="sd">        :param tb:      The stack trace of the exception raised by the failed task</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bg_tasks_group</span><span class="p">:</span>
            <span class="c1"># ignore - it isn&#39;t our task - this slot will recieve signals for tasks started</span>
            <span class="c1"># by other objects/instances so we need to make sure we filter them out here</span>
            <span class="k">return</span>

        <span class="c1"># remap task ids for thumbnails:</span>
        <span class="k">if</span> <span class="n">task_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="p">:</span>
            <span class="n">orig_task_id</span> <span class="o">=</span> <span class="n">task_id</span>
            <span class="n">task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thumb_task_id_map</span><span class="p">[</span><span class="n">orig_task_id</span><span class="p">]</span>

        <span class="c1"># remap task ids for attachments:</span>
        <span class="k">if</span> <span class="n">task_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="p">:</span>
            <span class="n">orig_task_id</span> <span class="o">=</span> <span class="n">task_id</span>
            <span class="n">task_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attachment_task_id_map</span><span class="p">[</span><span class="n">orig_task_id</span><span class="p">]</span>

        <span class="c1"># emit failure signal:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_failure</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">task_id</span><span class="p">),</span> <span class="n">msg</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Autodesk

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2114792-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>