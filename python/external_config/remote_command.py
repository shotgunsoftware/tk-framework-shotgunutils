# Copyright (c) 2017 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.


import os
import sys
import cPickle
import tempfile
import sgtk

logger = sgtk.platform.get_logger(__name__)


class RemoteCommand(object):
    """
    Represents a remote Toolkit command (e.g. menu option).

    These objects are emitted by :class:`RemoteConfiguration`.
    """

    @classmethod
    def serialize_command(cls, entity, engine_name, command_name, properties):
        """
        Generates a data chunk given a set of standard
        toolkit command data, as obtained from engine.commands.

        :param str command_name: Command name (the key
            name for an entry in engine.commands)
        :param dict properties: Properties dictionary
            as returned by engine.commands.
        :returns: dictionary suitable to pass to :meth:`create`.
        """
        data = {
            "entity": entity,
            "engine_name": engine_name,
            "callback_name": command_name,
            "display_name": properties.get("title") or command_name,
            "tooltip": properties.get("description") or "",
            "type": properties.get("type"),
            "icon": properties.get("icon"),
            "group": properties.get("group"),
            "group_default": properties.get("group_default") or False,

            # special for shotgun
            "deny_permissions": properties.get("deny_permissions"),
            "deny_platforms": properties.get("deny_platforms"),
            "supports_multiple_selection": properties.get("supports_multiple_selection"),
        }

        return data

    @classmethod
    def create(cls, remote_configuration, data):
        """
        Creates a new :class:`RemoteCommand` instance based on the
        data in data. This data is generated by :meth:`serialize_command`.

        :param dict data: Serialized data to be turned into an instance
        :returns: :class:`RemoteCommand` instance.
        """

        return RemoteCommand(
            callback_name=data["callback_name"],
            display_name=data["display_name"],
            tooltip=data["tooltip"],
            python_interpreter=remote_configuration.associated_python_interpreter,
            descriptor_uri=remote_configuration.descriptor_uri,
            pipeline_config_id=remote_configuration.pipeline_configuration_id,
            plugin_id=remote_configuration.plugin_id,
            engine_name=data["engine_name"],
            entity_type=data["entity"]["type"],
            entity_id=data["entity"]["id"],

        )

    def __init__(
            self,
            callback_name,
            display_name,
            tooltip,
            python_interpreter,
            descriptor_uri,
            pipeline_config_id,
            plugin_id,
            engine_name,
            entity_type,
            entity_id,
    ):
        """
        """
        super(RemoteCommand, self).__init__()

        # keep a handle to the current app/engine/fw bundle for convenience
        self._bundle = sgtk.platform.current_bundle()

        self._callback_name = callback_name
        self._display_name = display_name
        self._tooltip = tooltip
        self._python_interpreter = python_interpreter
        self._descriptor_uri = descriptor_uri
        self._pipeline_config_id = pipeline_config_id
        self._plugin_id = plugin_id
        self._engine_name = engine_name
        self._entity_type = entity_type
        self._entity_id = entity_id

    def __repr__(self):
        return "<RemoteCommand>"

    @classmethod
    def from_string(cls, data):
        """
        Creates a :class:`RemoteCommand` instance given some serialized data.

        :param str data: Data created by :meth:`to_string`
        :returns: Remote Command instance.
        :rtype: :class:`RemoteCommand`
        """
        data = data.encode("utf-8")
        data = cPickle.loads(data)
        return RemoteCommand(
            callback_name=data["callback_name"],
            display_name=data["display_name"],
            tooltip=data["tooltip"],
            python_interpreter=data["python_interpreter"],
            descriptor_uri=data["descriptor_uri"],
            pipeline_config_id=data["pipeline_config_id"],
            plugin_id=data["plugin_id"],
            engine_name=data["engine_name"],
            entity_type=data["entity_type"],
            entity_id=data["entity_id"],
        )


    def to_string(self):
        """
        Serializes the current object into a string.

        For use with :meth:`from_string`.

        :returns: String representing the current instance.
        :rtype: str
        """
        data = {
            "callback_name": self._callback_name,
            "display_name": self._display_name,
            "tooltip": self._tooltip,
            "python_interpreter": self._python_interpreter,
            "descriptor_uri": self._descriptor_uri,
            "pipeline_config_id": self._pipeline_config_id,
            "plugin_id": self._plugin_id,
            "engine_name": self._engine_name,
            "entity_type": self._entity_type,
            "entity_id": self._entity_id
        }
        return cPickle.dumps(data)

    @property
    def display_name(self):
        """
        The name of the command
        """
        return self._display_name

    def tooltip(self):
        """
        The tooltip for the command
        """
        return self._tooltip

    def execute(self):
        """
        Executes the remote command
        """
        from .process_execution import ProcessRunner
        logger.debug("%s: execute command" % self)

        script = os.path.abspath(
            os.path.join(
                os.path.dirname(__file__),
                "scripts",
                "execute_command.py"
            )
        )

        args_file = self._get_arguments_file(
            dict(
                callback_name=self._callback_name,
                core_path=sgtk.bootstrap.ToolkitManager.get_core_python_path(),
                configuration_uri=self._descriptor_uri,
                pipeline_config_id=self._pipeline_config_id,
                plugin_id=self._plugin_id,
                engine_name=self._engine_name,
                entity_type=self._entity_type,
                entity_id=self._entity_id,
                bundle_cache_fallback_paths=self._bundle.engine.sgtk.bundle_cache_fallback_paths,
            )
        )

        args = [self._python_interpreter, script, args_file]
        logger.debug("Command arguments: %s", args)

        retcode, stdout, stderr = ProcessRunner.call_cmd(args)

        if retcode == 0:
            logger.error("Command stdout: %s", stdout)
            logger.error("Command stderr: %s", stderr)
        else:
            logger.error("Command failed: %s", args)
            logger.error("Failed command stdout: %s", stdout)
            logger.error("Failed command stderr: %s", stderr)
            logger.error("Failed command retcode: %s", retcode)
            raise Exception("%s\n\n%s" % (stdout, stderr))

        logger.debug("Execution complete.")

    def _get_arguments_file(self, args_data):
        """
        Dumps out a temporary file containing the provided data structure.

        TODO - this is duplicated in two places. clean up.

        :param args_data: The data to serialize to disk.

        :returns: File path
        :rtype: str
        """
        args_file = tempfile.mkstemp()[1]

        with open(args_file, "wb") as fh:
            cPickle.dump(
                args_data,
                fh,
                cPickle.HIGHEST_PROTOCOL,
            )

        return args_file
