# Copyright (c) 2018 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.
import os
import cPickle
import sgtk

logger = sgtk.platform.get_logger(__name__)

# file format magic number
CONFIGURATION_GENERATION = 2


class ExternalCommand(object):
    """
    Represents an external Toolkit command (e.g. menu option).

    These objects are emitted by :class:`ExternalConfiguration`
    and are independent, decoupled, light weight objects that
    can be serialized and brought back easily.

    A command is executed via its :meth:`execute` method, which
    will launch it in the given engine.
    """

    @classmethod
    def serialize_command(cls, entity_type, command_name, properties):
        """
        Generates a data chunk given a set of standard
        Toolkit command data, as obtained from engine.commands.

        This can be passed to :meth:`create` in order to construct a
        :class:`ExternalCommand` instance.

        :param str entity_type: Shotgun entity type that the
            command is associated with.
        :param str command_name: Command name (the key
            name for an entry in engine.commands)
        :param dict properties: Properties dictionary
            as returned by the ``Engine.commands`` dictionary property.
        :returns: dictionary suitable to pass to :meth:`create`.
        """
        data = {
            "entity_type": entity_type,
            "callback_name": command_name,
            "display_name": properties.get("title") or command_name,
            "tooltip": properties.get("description") or "",
            "type": properties.get("type"),
            "icon": properties.get("icon"),
            "group": properties.get("group"),
            "group_default": properties.get("group_default") or False,

            # special for shotgun
            "deny_permissions": properties.get("deny_permissions"),
            "deny_platforms": properties.get("deny_platforms"),
            "supports_multiple_selection": properties.get("supports_multiple_selection"),
        }

        return data

    @classmethod
    def create(cls, external_configuration, data, entity_id):
        """
        Creates a new :class:`ExternalCommand` instance based on the
        data in data. This data is generated by :meth:`serialize_command`.

        :param external_configuration: associated :class:`ExternalConfiguration` instance.
        :param dict data: Serialized data to be turned into an instance
        :param int entity_id: The data is cached in a general form, suitable for
            all entities. This means that the entity_id cached as part of the
            ``data`` parameter reflects the entity for which the caching process
            was executed and not necessarily the one we are after. This parameter
            indicates the actual entity id for which we want the commands to be
            assoiated.
        :returns: :class:`ExternalCommand` instance.
        """
        return ExternalCommand(
            callback_name=data["callback_name"],
            display_name=data["display_name"],
            tooltip=data["tooltip"],
            plugin_id=external_configuration.plugin_id,
            engine_name=external_configuration.engine_name,
            interpreter=external_configuration.interpreter,
            descriptor_uri=external_configuration.descriptor_uri,
            pipeline_config_id=external_configuration.pipeline_configuration_id,
            entity_type=data["entity_type"],
            entity_id=entity_id,
            pipeline_config_name=external_configuration.pipeline_configuration_name,
        )

    def __init__(
            self,
            callback_name,
            display_name,
            tooltip,
            plugin_id,
            interpreter,
            engine_name,
            descriptor_uri,
            pipeline_config_id,
            entity_type,
            entity_id,
            pipeline_config_name
    ):
        """
        .. note:: This class is constructed by :class:`ExternalConfigurationLoader`.
            Do not construct objects by hand.

        :param str callback_name: Name of the associated Toolkit command callback
        :param str display_name: Display name for command
        :param str tooltip: Tooltip
        :param str plugin_id: Plugin id
        :param str interpreter: Associated Python interpreter
        :param str engine_name: Engine name to execute command in
        :param str descriptor_uri: Associated descriptor URI
        :param int pipeline_config_id: Associated pipeline configuration id
        :param str entity_type: Associated entity type
        :param int entity_id: Associated entity id
        :param str pipeline_config_name: Associated pipeline configuration name
        """
        super(ExternalCommand, self).__init__()

        # keep a handle to the current app/engine/fw bundle for convenience
        self._bundle = sgtk.platform.current_bundle()

        self._callback_name = callback_name
        self._display_name = display_name
        self._tooltip = tooltip
        self._interpreter = interpreter
        self._descriptor_uri = descriptor_uri
        self._pipeline_config_id = pipeline_config_id
        self._plugin_id = plugin_id
        self._engine_name = engine_name
        self._entity_type = entity_type
        self._entity_id = entity_id
        self._pipeline_config_name = pipeline_config_name

    def __repr__(self):
        """
        String representation
        """
        return "<ExternalCommand %s @ %s %s %s>" % (
            self._display_name,
            self._engine_name,
            self._entity_type,
            self._entity_id
        )

    @classmethod
    def deserialize(cls, data):
        """
        Creates a :class:`ExternalCommand` instance given some serialized data.

        :param str data: Data created by :meth:`serialize`
        :returns: External Command instance.
        :rtype: :class:`ExternalCommand`
        :raises: :class:`RuntimeError` if data is not valid
        """
        data = cPickle.loads(data)

        if data.get("GENERATION") != CONFIGURATION_GENERATION:
            raise RuntimeError(
                "Format is incompatible. Serialized data "
                "is of generation %s, code expects "
                "generation %s" % (data.get("GENERATION"), CONFIGURATION_GENERATION)
            )

        return ExternalCommand(
            callback_name=data["callback_name"],
            display_name=data["display_name"],
            tooltip=data["tooltip"],
            plugin_id=data["plugin_id"],
            engine_name=data["engine_name"],
            interpreter=data["interpreter"],
            descriptor_uri=data["descriptor_uri"],
            pipeline_config_id=data["pipeline_config_id"],
            entity_type=data["entity_type"],
            entity_id=data["entity_id"],
            pipeline_config_name=data["pipeline_config_name"]
        )

    def serialize(self):
        """
        Serializes the current object into a string.

        For use with :meth:`deserialize`.

        :returns: String representing the current instance.
        :rtype: str
        """
        data = {
            "GENERATION": CONFIGURATION_GENERATION,
            "callback_name": self._callback_name,
            "display_name": self._display_name,
            "tooltip": self._tooltip,
            "plugin_id": self._plugin_id,
            "engine_name": self._engine_name,
            "interpreter": self._interpreter,
            "descriptor_uri": self._descriptor_uri,
            "pipeline_config_id": self._pipeline_config_id,
            "entity_type": self._entity_type,
            "entity_id": self._entity_id,
            "pipeline_config_name": self._pipeline_config_name

        }
        return cPickle.dumps(data)

    @property
    def pipeline_configuration_name(self):
        """
        The name of the Shotgun pipeline configuration this command is associated with,
        or ``None`` if no association exists.
        """
        return self._pipeline_config_name

    @property
    def display_name(self):
        """
        Display name, suitable for display in a menu.
        """
        return self._display_name

    @property
    def tooltip(self):
        """
        Associated help text tooltip.
        """
        return self._tooltip

    def execute(self):
        """
        Executes the external command in a separate process.

        .. note:: The process will be launched in an asynchronous way.
            It is recommended that this command is executed in a worker thread.
        """
        # local imports because this is executed from runner scripts
        from .process_execution import ProcessRunner
        from .util import create_parameter_file

        logger.debug("%s: execute command" % self)

        # prepare execution of the command in an external process
        # this will bootstrap Toolkit and execute the command.
        script = os.path.abspath(
            os.path.join(
                os.path.dirname(__file__),
                "scripts",
                "external_runner.py"
            )
        )
        # pass arguments via a pickled temp file.
        args_file = create_parameter_file(
            dict(
                action="execute_command",
                callback_name=self._callback_name,
                configuration_uri=self._descriptor_uri,
                pipeline_config_id=self._pipeline_config_id,
                plugin_id=self._plugin_id,
                engine_name=self._engine_name,
                entity_type=self._entity_type,
                entity_id=self._entity_id,
                bundle_cache_fallback_paths=self._bundle.engine.sgtk.bundle_cache_fallback_paths,
            )
        )
        # compose the command we want to run
        args = [
            self._interpreter,
            script,
            sgtk.bootstrap.ToolkitManager.get_core_python_path(),
            args_file
        ]
        logger.debug("Command arguments: %s", args)

        retcode, stdout, stderr = ProcessRunner.call_cmd(args)

        if retcode == 0:
            logger.debug("Command stdout: %s", stdout)
            logger.debug("Command stderr: %s", stderr)
        else:
            logger.error("Command failed: %s", args)
            logger.error("Failed command stdout: %s", stdout)
            logger.error("Failed command stderr: %s", stderr)
            logger.error("Failed command retcode: %s", retcode)
            raise RuntimeError("%s\n\n%s" % (stdout, stderr))

        logger.debug("Execution complete.")

